{"version":3,"sources":["components/Maze/Maze.module.scss","components/SelectionBar/SelectionBar.module.scss","components/SelectionBar/index.ts","components/SelectionBar/SelectionBar.tsx","service/mazeGenerator.service.ts","service/mazeSolver.service.ts","components/Maze/Canvas/Canvas.tsx","components/Maze/index.ts","components/Maze/Maze.tsx","App.tsx","reportWebVitals.ts","index.tsx"],"names":["module","exports","SelectionBar","className","styles","selectionBar","Walls","N","E","S","W","this","Cell","x","y","walls","visited","backtracked","Grid","width","height","grid","stack","frames","algorithm","possibleMoves","cell","moves","push","row","cloneDeep","canvasContext","unitSize","step","clearRect","beginPath","forEach","strokeStyle","lineWidth","fillStyle","fillRect","moveTo","lineTo","stroke","lineJoin","rect","fill","RecursiveBacktrackMaze","generateMaze","currentFrame","directions","direction","Math","floor","random","length","newCell","newCellFromDirection","newDirection","newDirectionFromDirection","oldCell","pop","DijkstraCell","distanceFromSource","moveCost","onPath","Infinity","distance","DijkstraMaze","maze","getUnvisitedNeighbours","cellWalls","Object","entries","key","filter","n","includes","map","move","cellFromDirection","candidate","reduce","lowest","undefined","updateNeighbourDistances","currentCell","targetCell","updateDistance","dijkstraSolve","submission","t0","performance","now","exitCell","unvisitedCells","nodes","getAllNodes","startCell","sort","firstNode","secondNode","shift","console","log","nextCell","getBestPathNeighbor","t1","Canvas","delayBetweenFrames","canvasRef","useRef","useState","setStep","measured","setMeasured","setUnitSize","document","createElement","getContext","context","setContext","useEffect","canvas","current","tmpContext","parentDiv","parentElement","offsetWidth","offsetHeight","tempUnitSize","translate","Error","draw","setTimeout","ref","Maze","dimensions","setMaze","setFrameDelay","mazeContainer","id","onClick","lastFrame","generateRecursiveBacktrackMaze","type","min","max","defaultValue","onChange","event","newDelay","Number","target","value","App","reportWebVitals","onPerfEntry","Function","then","getCLS","getFID","getFCP","getLCP","getTTFB","ReactDOM","render","StrictMode","getElementById"],"mappings":"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","file":"static/js/main.0c1eb99d.chunk.js","sourcesContent":["// extracted by mini-css-extract-plugin\nmodule.exports = {\"mazeContainer\":\"Maze_mazeContainer__3Exuk\",\"maze\":\"Maze_maze__2NaIp\"};","// extracted by mini-css-extract-plugin\nmodule.exports = {\"selectionBar\":\"SelectionBar_selectionBar__14QJ9\"};","import SelectionBar from \"./SelectionBar\";\n\nexport default SelectionBar","import React from 'react'\nimport styles from './SelectionBar.module.scss'\n\nconst SelectionBar = () => {\n    return (\n        <div className={styles.selectionBar}>\n            <h1>Maze Generator</h1>\n        </div>\n    )\n}\n\nexport default SelectionBar\n","import { cloneDeep } from \"lodash\";\n\nexport class Walls {\n  N: boolean;\n  E: boolean;\n  S: boolean;\n  W: boolean;\n  [key: string]: boolean;\n\n  constructor() {\n    this.N = true;\n    this.E = true;\n    this.S = true;\n    this.W = true;\n  }\n}\n\nexport class Cell {\n  x: number;\n  y: number;\n  walls: Walls;\n  visited: boolean;\n  backtracked: boolean;\n\n  constructor(x: number, y: number) {\n    this.x = x;\n    this.y = y;\n    this.walls = new Walls();\n    this.visited = false;\n    this.backtracked = false;\n  }\n}\n\nexport class Grid {\n  height: number;\n  width: number;\n  grid: Cell[][];\n  stack: Cell[];\n  frames: Cell[][][];\n  algorithm: string;\n  [key: string]: any;\n\n  constructor(width: number, height: number) {\n    this.height = height <= 50 ? height : 50;\n    this.width = width <= 50 ? width : 50;\n    this.grid = [];\n    this.stack = [];\n    this.algorithm = \"grid\";\n\n    for (let x = 0; x < width; x++) {\n      let row = [];\n      for (let y = 0; y < height; y++) {\n        row.push(new Cell(x, y));\n      }\n      this.grid.push(row);\n    }\n\n    this.frames = cloneDeep([this.grid]);\n    this.grid[0][0].visited = true;\n  }\n\n  possibleMoves = (cell: Cell): string[] => {\n    let moves = [];\n    if (cell.y - 1 >= 0 && !this.grid[cell.x][cell.y - 1].visited) moves.push(\"N\");\n    if (cell.x + 1 < this.width && !this.grid[cell.x + 1][cell.y].visited)\n      moves.push(\"E\");\n    if (cell.y + 1 < this.height && !this.grid[cell.x][cell.y + 1].visited)\n      moves.push(\"S\");\n    if (cell.x - 1 >= 0 && !this.grid[cell.x - 1][cell.y].visited) moves.push(\"W\");\n    return moves;\n  };\n\n  generateMaze(cell: Cell) {}\n\n  draw(canvasContext: any, unitSize: number, step: number) {\n    canvasContext.clearRect(0, 0, unitSize * this.width, unitSize * this.height);\n    canvasContext.beginPath();\n    this.frames[step].forEach((row) => {\n      canvasContext.strokeStyle = \"#800080\";\n      canvasContext.lineWidth = 5;\n      row.forEach((cell) => {\n        canvasContext.fillStyle = \"#FDA4BA\";\n        if (cell.visited && !cell.backtracked) {\n          canvasContext.fillRect(\n            cell.x * unitSize,\n            cell.y * unitSize,\n            unitSize + 1,\n            unitSize + 1\n          );\n        }\n        canvasContext.moveTo(cell.x * unitSize - 2.5, cell.y * unitSize);\n        if (cell.walls.N) {\n          canvasContext.lineTo(cell.x * unitSize + unitSize, cell.y * unitSize);\n        } else {\n          canvasContext.moveTo(cell.x * unitSize + unitSize, cell.y * unitSize);\n        }\n        if (cell.walls.E) {\n          canvasContext.lineTo(\n            cell.x * unitSize + unitSize,\n            cell.y * unitSize + unitSize\n          );\n        } else {\n          canvasContext.moveTo(\n            cell.x * unitSize + unitSize,\n            cell.y * unitSize + unitSize\n          );\n        }\n        if (cell.walls.S) {\n          canvasContext.lineTo(cell.x * unitSize, cell.y * unitSize + unitSize);\n        } else {\n          canvasContext.moveTo(cell.x * unitSize, cell.y * unitSize + unitSize);\n        }\n        if (cell.walls.W) {\n          canvasContext.lineTo(cell.x * unitSize, cell.y * unitSize);\n        } else {\n          canvasContext.moveTo(cell.x * unitSize, cell.y * unitSize);\n        }\n      });\n    });\n    canvasContext.stroke();\n\n    canvasContext.beginPath();\n    canvasContext.lineJoin = \"round\";\n    canvasContext.lineWidth = 10;\n    canvasContext.rect(0, 0, this.width * unitSize, this.height * unitSize);\n    canvasContext.stroke();\n\n    canvasContext.beginPath();\n    canvasContext.lineWidth = 10;\n    canvasContext.strokeStyle = \"#FFFFFF\";\n    canvasContext.moveTo(0, 5);\n    canvasContext.lineTo(0, unitSize - 2.5);\n    canvasContext.moveTo(this.width * unitSize, this.height * unitSize - 5);\n    canvasContext.lineTo(\n      this.width * unitSize,\n      this.height * unitSize - unitSize + 2.5\n    );\n    canvasContext.stroke();\n\n    canvasContext.beginPath();\n    canvasContext.lineWidth = 3;\n    canvasContext.fillStyle = \"#000000\";\n    canvasContext.moveTo(unitSize / 4, unitSize / 4);\n    canvasContext.lineTo(3 * (unitSize / 4), unitSize / 2);\n    canvasContext.lineTo(unitSize / 4, 3 * (unitSize / 4));\n    canvasContext.fill();\n\n    canvasContext.beginPath();\n    canvasContext.moveTo(\n      this.width * unitSize - 3 * (unitSize / 4),\n      this.height * unitSize - 3 * (unitSize / 4)\n    );\n    canvasContext.lineTo(\n      this.width * unitSize - unitSize / 4,\n      this.height * unitSize - unitSize / 2\n    );\n    canvasContext.lineTo(\n      this.width * unitSize - 3 * (unitSize / 4),\n      this.height * unitSize - unitSize / 4\n    );\n    canvasContext.fill();\n  }\n}\n\nexport class RecursiveBacktrackMaze extends Grid {\n  constructor(width: number, height: number) {\n    super(height, width);\n    this.algorithm = \"recursiveBacktrackGenerate\";\n    this.generateMaze(this.grid[0][0]);\n  }\n\n  generateMaze = (cell: Cell) => {\n    const currentFrame = cloneDeep(this.grid);\n    this.frames.push(currentFrame);\n\n    const newCellFromDirection = (direction: string): Cell | null => {\n      switch (direction) {\n        case \"N\":\n          return this.grid[cell.x][cell.y - 1];\n        case \"E\":\n          return this.grid[cell.x + 1][cell.y];\n        case \"S\":\n          return this.grid[cell.x][cell.y + 1];\n        case \"W\":\n          return this.grid[cell.x - 1][cell.y];\n        default:\n          return null;\n      }\n    };\n\n    const newDirectionFromDirection = (direction: string): string | null => {\n      switch (direction) {\n        case \"N\":\n          return \"S\";\n        case \"E\":\n          return \"W\";\n        case \"S\":\n          return \"N\";\n        case \"W\":\n          return \"E\";\n        default:\n          return null;\n      }\n    };\n    const directions = this.possibleMoves(cell);\n    const direction = directions[Math.floor(Math.random() * directions.length)];\n    const newCell = newCellFromDirection(direction);\n    const newDirection = newDirectionFromDirection(direction);\n\n    if (!newCell && !(this.stack.length > 0)) return;\n\n    if (newCell && newDirection) {\n      this.stack.push(cell);\n      cell.walls[direction] = false;\n      newCell.walls[newDirection] = false;\n      newCell.visited = true;\n      this.generateMaze(newCell);\n    } else {\n      cell.backtracked = true;\n      const oldCell = this.stack.pop();\n      if (oldCell) {\n        this.generateMaze(oldCell);\n      }\n    }\n  };\n}\n\nexport const generateRecursiveBacktrackMaze = (\n  height: number = 10,\n  width: number = 10,\n  render: boolean = true\n): RecursiveBacktrackMaze => {\n  const t0 = performance.now();\n  const maze = new RecursiveBacktrackMaze(width, height);\n  let lastFrame = maze.frames.pop();\n  if (lastFrame) {\n    lastFrame[0][0].backtracked = true;\n    maze.frames.push(lastFrame);\n  }\n  const t1 = performance.now();\n  console.log(\"maze generated in: \", t1 - t0, \" milliseconds.\");\n  return maze;\n};\n","import { RecursiveBacktrackMaze, Walls, Cell, Grid } from \"./mazeGenerator.service\";\nimport { cloneDeep } from \"lodash\";\n\nclass CellForSolving extends Cell {\n  visited: boolean;\n  walls: Walls;\n\n  constructor(cell: Cell) {\n    super(cell.x, cell.y);\n    this.visited = false;\n    this.walls = cell.walls;\n  }\n}\n\nclass DijkstraCell extends CellForSolving {\n  distanceFromSource: number;\n  moveCost: number;\n  onPath: boolean;\n\n  constructor(cell: Cell) {\n    super(cell);\n    this.distanceFromSource = Infinity;\n    this.moveCost = 1;\n    this.onPath = false;\n  }\n\n  setDistanceFromSource(distance: number) {\n    this.distanceFromSource = distance;\n  }\n}\n\nexport class DijkstraMaze extends Grid {\n  height: number;\n  width: number;\n  grid: DijkstraCell[][];\n  frames: DijkstraCell[][][];\n\n  constructor(maze: RecursiveBacktrackMaze) {\n    super(maze.width, maze.height);\n    this.height = maze.height;\n    this.width = maze.width;\n    this.frames = [];\n    this.algorithm = \"DijkstraSolve\";\n\n    this.grid = maze.grid.map((row) => {\n      return row.map((cell) => {\n        return new DijkstraCell(cell);\n      });\n    });\n  }\n\n  getUnvisitedNeighbours = (cell: DijkstraCell): DijkstraCell[] => {\n    let allMoves = [\"N\", \"E\", \"S\", \"W\"];\n    let cellWalls: string[] = [];\n\n    Object.entries(cell.walls).forEach(([key, value]) => {\n      if (value) cellWalls.push(key);\n    });\n\n    const cellFromDirection = (direction: string): DijkstraCell | null => {\n      switch (direction) {\n        case \"N\":\n          if (!this.grid[cell.x][cell.y - 1].visited)\n            return this.grid[cell.x][cell.y - 1];\n          return null;\n        case \"E\":\n          if (!this.grid[cell.x + 1][cell.y].visited)\n            return this.grid[cell.x + 1][cell.y];\n          return null;\n        case \"S\":\n          if (!this.grid[cell.x][cell.y + 1].visited)\n            return this.grid[cell.x][cell.y + 1];\n          return null;\n        case \"W\":\n          if (!this.grid[cell.x - 1][cell.y].visited)\n            return this.grid[cell.x - 1][cell.y];\n          return null;\n        default:\n          return null;\n      }\n    };\n\n    const isCell = (candidate: any): candidate is DijkstraCell => {\n      if (candidate instanceof DijkstraCell) return true;\n      return false;\n    };\n\n    const cellMoves = allMoves\n      .filter((n) => !cellWalls.includes(n))\n      .map((move) => cellFromDirection(move));\n    const validMoves: DijkstraCell[] = cellMoves.filter(isCell)!;\n\n    return validMoves;\n  };\n\n  getBestPathNeighbor(cell: DijkstraCell) {\n    let allMoves = [\"N\", \"E\", \"S\", \"W\"];\n    let cellWalls: string[] = [];\n\n    Object.entries(cell.walls).forEach(([key, value]) => {\n      if (value) cellWalls.push(key);\n    });\n\n    const cellFromDirection = (direction: string): DijkstraCell | null => {\n      switch (direction) {\n        case \"N\":\n          if (!this.grid[cell.x][cell.y - 1].onPath)\n            return this.grid[cell.x][cell.y - 1];\n          return null;\n        case \"E\":\n          if (!this.grid[cell.x + 1][cell.y].onPath)\n            return this.grid[cell.x + 1][cell.y];\n          return null;\n        case \"S\":\n          if (!this.grid[cell.x][cell.y + 1].onPath)\n            return this.grid[cell.x][cell.y + 1];\n          return null;\n        case \"W\":\n          if (!this.grid[cell.x - 1][cell.y].onPath)\n            return this.grid[cell.x - 1][cell.y];\n          return null;\n        default:\n          return null;\n      }\n    };\n\n    const isCell = (candidate: any): candidate is DijkstraCell => {\n      if (candidate instanceof DijkstraCell) return true;\n      return false;\n    };\n\n    const cellMoves = allMoves\n      .filter((n) => !cellWalls.includes(n))\n      .map((move) => cellFromDirection(move));\n    const validMoves: DijkstraCell[] = cellMoves.filter(isCell)!;\n\n    return validMoves.reduce((lowest, cell) =>\n      lowest.distanceFromSource < cell.distanceFromSource ? lowest : cell\n    );\n  }\n\n  draw(canvasContext: any, unitSize: number, step: number) {\n    canvasContext.clearRect(0, 0, unitSize * this.width, unitSize * this.height);\n    if (this.frames[step] === undefined) return;\n    canvasContext.strokeStyle = \"#800080\";\n    canvasContext.lineWidth = 5;\n    canvasContext.beginPath();\n    this.frames[step].forEach((row) => {\n      row.forEach((cell) => {\n        if (cell.visited) {\n          canvasContext.fillStyle = \"#FDA4BA\";\n          canvasContext.fillRect(\n            cell.x * unitSize,\n            cell.y * unitSize,\n            unitSize + 1,\n            unitSize + 1\n          );\n        }\n\n        if (cell.onPath) {\n          canvasContext.fillStyle = \"#00BFFF\";\n          canvasContext.fillRect(\n            cell.x * unitSize,\n            cell.y * unitSize,\n            unitSize,\n            unitSize\n          );\n        }\n\n        canvasContext.moveTo(cell.x * unitSize - 2.5, cell.y * unitSize);\n        if (cell.walls.N) {\n          canvasContext.lineTo(cell.x * unitSize + unitSize, cell.y * unitSize);\n        } else {\n          canvasContext.moveTo(cell.x * unitSize + unitSize, cell.y * unitSize);\n        }\n        if (cell.walls.E) {\n          canvasContext.lineTo(\n            cell.x * unitSize + unitSize,\n            cell.y * unitSize + unitSize\n          );\n        } else {\n          canvasContext.moveTo(\n            cell.x * unitSize + unitSize,\n            cell.y * unitSize + unitSize\n          );\n        }\n        if (cell.walls.S) {\n          canvasContext.lineTo(cell.x * unitSize, cell.y * unitSize + unitSize);\n        } else {\n          canvasContext.moveTo(cell.x * unitSize, cell.y * unitSize + unitSize);\n        }\n        if (cell.walls.W) {\n          canvasContext.lineTo(cell.x * unitSize, cell.y * unitSize);\n        } else {\n          canvasContext.moveTo(cell.x * unitSize, cell.y * unitSize);\n        }\n      });\n    });\n    canvasContext.stroke();\n\n    canvasContext.beginPath();\n    canvasContext.lineJoin = \"round\";\n    canvasContext.lineWidth = 10;\n    canvasContext.rect(0, 0, this.width * unitSize, this.height * unitSize);\n    canvasContext.stroke();\n\n    canvasContext.beginPath();\n    canvasContext.lineWidth = 10;\n    canvasContext.strokeStyle = \"#FFFFFF\";\n    canvasContext.moveTo(0, 5);\n    canvasContext.lineTo(0, unitSize - 2.5);\n    canvasContext.moveTo(this.width * unitSize, this.height * unitSize - 5);\n    canvasContext.lineTo(\n      this.width * unitSize,\n      this.height * unitSize - unitSize + 2.5\n    );\n    canvasContext.stroke();\n\n    canvasContext.beginPath();\n    canvasContext.lineWidth = 3;\n    canvasContext.fillStyle = \"#000000\";\n    canvasContext.moveTo(unitSize / 4, unitSize / 4);\n    canvasContext.lineTo(3 * (unitSize / 4), unitSize / 2);\n    canvasContext.lineTo(unitSize / 4, 3 * (unitSize / 4));\n    canvasContext.fill();\n\n    canvasContext.beginPath();\n    canvasContext.moveTo(\n      this.width * unitSize - 3 * (unitSize / 4),\n      this.height * unitSize - 3 * (unitSize / 4)\n    );\n    canvasContext.lineTo(\n      this.width * unitSize - unitSize / 4,\n      this.height * unitSize - unitSize / 2\n    );\n    canvasContext.lineTo(\n      this.width * unitSize - 3 * (unitSize / 4),\n      this.height * unitSize - unitSize / 4\n    );\n    canvasContext.fill();\n  }\n}\n\nconst getAllNodes = (grid: DijkstraCell[][]): DijkstraCell[] => {\n  let nodes: DijkstraCell[] = [];\n  for (let row of grid) {\n    for (let cell of row) {\n      nodes.push(cell);\n    }\n  }\n  return nodes;\n};\n\nconst sortNodesByDistance = (nodeList: DijkstraCell[]) => {\n  return nodeList.sort(\n    (firstNode, secondNode) =>\n      firstNode.distanceFromSource - secondNode.distanceFromSource\n  );\n};\n\nconst updateDistance = (currentCell: DijkstraCell, targetCell: DijkstraCell) => {\n  targetCell.distanceFromSource =\n    currentCell.distanceFromSource + targetCell.moveCost;\n};\n\nconst updateNeighbourDistances = (currentCell: DijkstraCell, maze: DijkstraMaze) => {\n  const neighbours = maze.getUnvisitedNeighbours(currentCell);\n  neighbours.forEach((cell) => {\n    updateDistance(currentCell, cell);\n  });\n};\n\nexport const dijkstraSolve = (submission: Grid): DijkstraMaze => {\n  const t0 = performance.now();\n  const maze = new DijkstraMaze(submission);\n  const exitCell = maze.grid[maze.width - 1][maze.height - 1];\n  const unvisitedCells = getAllNodes(maze.grid);\n  const startCell = maze.grid[0][0];\n  startCell.distanceFromSource = 0;\n\n  while (!!unvisitedCells.length) {\n    sortNodesByDistance(unvisitedCells);\n    const currentCell = unvisitedCells.shift();\n\n    if (currentCell === undefined) break;\n    if (currentCell.distanceFromSource === Infinity) break;\n    if (currentCell === exitCell) break;\n\n    currentCell.visited = true;\n\n    updateNeighbourDistances(currentCell, maze);\n    maze.frames.push(cloneDeep(maze.grid));\n  }\n\n  let currentCell = exitCell;\n\n  while (!(currentCell === startCell)) {\n    console.log(currentCell);\n    currentCell.onPath = true;\n    const nextCell = maze.getBestPathNeighbor(currentCell);\n    maze.frames.push(cloneDeep(maze.grid));\n    currentCell = nextCell;\n  }\n\n  startCell.onPath = true;\n  maze.frames.push(cloneDeep(maze.grid));\n\n  const t1 = performance.now();\n  console.log(\"solved in:\", t1 - t0, \"milliseconds.\", maze);\n\n  return maze;\n};\n","import React, { useRef, useEffect, useState } from \"react\";\nimport {\n  Grid,\n  RecursiveBacktrackMaze,\n} from \"../../../service/mazeGenerator.service\";\nimport { DijkstraMaze } from \"../../../service/mazeSolver.service\";\n\ntype CanvasProps = {\n  maze: Grid | RecursiveBacktrackMaze | DijkstraMaze;\n  delayBetweenFrames: number;\n};\n\nconst Canvas = ({ maze, delayBetweenFrames }: CanvasProps) => {\n  const canvasRef = useRef(null);\n  const [step, setStep] = useState(0);\n  const [measured, setMeasured] = useState(false);\n  const [unitSize, setUnitSize] = useState(1);\n  const [context, setContext] = useState(\n    document.createElement(\"canvas\").getContext(\"2d\")\n  );\n\n  useEffect(() => {\n    setStep(0);\n    const canvas: any = canvasRef.current;\n    const tmpContext = canvas.getContext(\"2d\");\n    const parentDiv = canvas.parentElement;\n    if (!measured) {\n      tmpContext.canvas.width = parentDiv?.offsetWidth;\n      tmpContext.canvas.height = parentDiv?.offsetHeight;\n      let tempUnitSize = 1;\n      while (\n        tempUnitSize * maze.height < tmpContext.canvas.height - 50 &&\n        tempUnitSize * maze.width < tmpContext.canvas.width - 50\n      ) {\n        tempUnitSize += 1;\n      }\n      setUnitSize(tempUnitSize);\n      setMeasured(true);\n      tmpContext.translate(5, 5);\n      setContext(tmpContext);\n    }\n  }, [maze, measured]);\n\n  useEffect(() => {\n    if (!context) throw new Error(\"No context\");\n\n    maze.draw(context, unitSize, step);\n\n    setTimeout(() => {\n      if (step + 1 < maze.frames.length) setStep(step + 1);\n    }, delayBetweenFrames);\n  }, [step, context, maze, unitSize, delayBetweenFrames]);\n\n  return <canvas ref={canvasRef} />;\n};\n\nexport default Canvas;\n","import Maze from \"./Maze\";\n\nexport default Maze","import React, { useState, useEffect } from \"react\";\nimport styles from \"./Maze.module.scss\";\nimport {\n  generateRecursiveBacktrackMaze,\n  Grid,\n} from \"../../service/mazeGenerator.service\";\nimport { dijkstraSolve } from \"../../service/mazeSolver.service\";\nimport Canvas from \"./Canvas/Canvas\";\nimport { cloneDeep } from \"lodash\";\n\nconst Maze = () => {\n  const [dimensions] = useState({ width: 15, height: 10 });\n  const [maze, setMaze] = useState(new Grid(dimensions.width, dimensions.height));\n  const [delayBetweenFrames, setFrameDelay] = useState(1);\n\n  useEffect(() => {\n    // setDimensions({ width: 10, height: 10 });\n    console.log(maze);\n  }, [maze]);\n\n  const handleChange = (event: any): void => {\n    let newDelay = Number(event.target.value);\n    newDelay = Math.max(newDelay, 0);\n    newDelay = Math.min(newDelay, 2000);\n    setFrameDelay(newDelay);\n  };\n\n  return (\n    <div className={styles.mazeContainer}>\n      <div className={styles.maze} id=\"maze\">\n        <Canvas maze={maze} delayBetweenFrames={delayBetweenFrames} />\n        <button\n          onClick={() => {\n            setMaze(cloneDeep(maze));\n          }}\n        >\n          Re-run\n        </button>\n        <button\n          onClick={() => {\n            setMaze(\n              generateRecursiveBacktrackMaze(dimensions.width, dimensions.height)\n            );\n          }}\n        >\n          New maze\n        </button>\n        Interval:{\" \"}\n        <input\n          type=\"number\"\n          min=\"0\"\n          max=\"2000\"\n          defaultValue={delayBetweenFrames}\n          onChange={handleChange}\n        />{\" \"}\n        ms.\n        <button\n          onClick={() => {\n            setMaze(dijkstraSolve(cloneDeep(maze)));\n          }}\n        >\n          Solve\n        </button>\n      </div>\n    </div>\n  );\n};\n\nexport default Maze;\n","import React from 'react';\nimport './App.css';\nimport SelectionBar from './components/SelectionBar';\nimport Maze from './components/Maze';\n\nfunction App() {\n  return (\n    <div className='App'>\n    <SelectionBar />\n    <Maze />\n    </div>\n  );\n}\n\nexport default App;\n","import { ReportHandler } from 'web-vitals';\n\nconst reportWebVitals = (onPerfEntry?: ReportHandler) => {\n  if (onPerfEntry && onPerfEntry instanceof Function) {\n    import('web-vitals').then(({ getCLS, getFID, getFCP, getLCP, getTTFB }) => {\n      getCLS(onPerfEntry);\n      getFID(onPerfEntry);\n      getFCP(onPerfEntry);\n      getLCP(onPerfEntry);\n      getTTFB(onPerfEntry);\n    });\n  }\n};\n\nexport default reportWebVitals;\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport reportWebVitals from './reportWebVitals';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n// If you want to start measuring performance in your app, pass a function\n// to log results (for example: reportWebVitals(console.log))\n// or send to an analytics endpoint. Learn more: https://bit.ly/CRA-vitals\nreportWebVitals();\n"],"sourceRoot":""}