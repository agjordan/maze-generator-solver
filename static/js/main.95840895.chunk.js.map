{"version":3,"sources":["components/Maze/Maze.module.scss","components/SelectionBar/SelectionBar.module.scss","components/SelectionBar/index.ts","components/SelectionBar/SelectionBar.tsx","service/mazeGenerator.service.ts","components/Maze/Canvas/Canvas.tsx","service/mazeSolver.service.ts","components/Maze/index.ts","components/Maze/Maze.tsx","App.tsx","reportWebVitals.ts","index.tsx"],"names":["module","exports","SelectionBar","className","styles","selectionBar","getNeighbourDirections","grid","relativeX","relativeY","directions","push","length","getOppositeDirection","direction","getRandomIntInclusive","min","max","Math","ceil","floor","random","getCellFromDirection","setWallForCellAndNeighbour","cell","addWalls","walls","firstX","x","firstY","y","abs","includes","neighbour","console","log","setWallForCollection","cells","forEach","Walls","N","E","S","W","this","EmptyWalls","Cell","visited","backtracked","RecursiveDivisionCell","currentArea","Grid","width","height","stack","frames","algorithm","createFrame","frame","cloneDeep","col","canvasContext","unitSize","step","beginPath","strokeStyle","lineWidth","fillStyle","fillRect","moveTo","lineTo","stroke","lineJoin","rect","fill","RecursiveBacktrackMaze","generateMaze","moves","possibleMoves","nextCell","oldCell","pop","t0","performance","now","lastFrame","t1","RecursiveDivisionMaze","recusiveDivisionGeneration","verticalSpace","index","row","map","randomCell","createHorizontalWallWithGate","half1","half2","slice","column","createVerticalWallWithGate","draw","topRow","botRow","Canvas","maze","delayBetweenFrames","canvasRef","useRef","useState","setStep","measured","setMeasured","setUnitSize","document","createElement","getContext","context","setContext","useEffect","canvas","current","tmpContext","parentDiv","parentElement","offsetWidth","offsetHeight","tempUnitSize","translate","Error","clearRect","font","fillText","setTimeout","ref","DijkstraCell","distanceFromSource","moveCost","onPath","Infinity","distance","DijkstraSolve","getUnvisitedNeighbours","cellWalls","Object","entries","key","filter","n","move","cellFromDirection","candidate","getAllNodes","nodes","updateNeighbourDistances","currentCell","targetCell","updateDistance","solve","exitCell","unvisitedCells","startCell","sort","firstNode","secondNode","shift","undefined","getBestPathNeighbor","reduce","lowest","Maze","dimensions","setMaze","setFrameDelay","mazeContainer","id","onClick","type","defaultValue","onChange","event","newDelay","Number","target","value","App","reportWebVitals","onPerfEntry","Function","then","getCLS","getFID","getFCP","getLCP","getTTFB","ReactDOM","render","StrictMode","getElementById"],"mappings":"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","file":"static/js/main.95840895.chunk.js","sourcesContent":["// extracted by mini-css-extract-plugin\nmodule.exports = {\"mazeContainer\":\"Maze_mazeContainer__3Exuk\",\"maze\":\"Maze_maze__2NaIp\"};","// extracted by mini-css-extract-plugin\nmodule.exports = {\"selectionBar\":\"SelectionBar_selectionBar__14QJ9\"};","import SelectionBar from \"./SelectionBar\";\n\nexport default SelectionBar","import React from 'react'\nimport styles from './SelectionBar.module.scss'\n\nconst SelectionBar = () => {\n    return (\n        <div className={styles.selectionBar}>\n            <h1>Maze Generator</h1>\n        </div>\n    )\n}\n\nexport default SelectionBar\n","import { cloneDeep } from \"lodash\";\n\nconst possibleMoves = (cell: Cell, grid: Cell[][]): string[] => {\n  let moves = [];\n  if (cell.y - 1 >= 0 && !grid[cell.x][cell.y - 1].visited) moves.push(\"N\");\n  if (cell.x + 1 < grid.length && !grid[cell.x + 1][cell.y].visited) moves.push(\"E\");\n  if (cell.y + 1 < grid[0].length && !grid[cell.x][cell.y + 1].visited)\n    moves.push(\"S\");\n  if (cell.x - 1 >= 0 && !grid[cell.x - 1][cell.y].visited) moves.push(\"W\");\n  return moves;\n};\n\nconst getNeighbourDirections = (\n  grid: Cell[][],\n  relativeX: number,\n  relativeY: number\n) => {\n  let directions = [];\n  if (relativeY - 1 >= 0) directions.push(\"N\");\n  if (relativeX + 1 < grid.length) directions.push(\"E\");\n  if (relativeY + 1 < grid[0].length) directions.push(\"S\");\n  if (relativeX - 1 >= 0) directions.push(\"W\");\n  return directions;\n};\n\nconst getOppositeDirection = (direction: string): string | null => {\n  switch (direction) {\n    case \"N\":\n      return \"S\";\n    case \"E\":\n      return \"W\";\n    case \"S\":\n      return \"N\";\n    case \"W\":\n      return \"E\";\n    default:\n      return null;\n  }\n};\n\nconst getRandomIntInclusive = (min: number, max: number): number => {\n  min = Math.ceil(min);\n  max = Math.floor(max);\n  return Math.floor(Math.random() * (max - min + 1) + min);\n};\n\nconst getCellFromDirection = (\n  direction: string,\n  grid: Cell[][],\n  relativeX: number,\n  relativeY: number\n): Cell | undefined => {\n  switch (direction) {\n    case \"N\":\n      if (relativeY - 1 >= 0) return grid[relativeX][relativeY - 1];\n      return undefined;\n    case \"E\":\n      if (relativeX + 1 < grid.length) return grid[relativeX + 1][relativeY];\n      return undefined;\n    case \"S\":\n      if (relativeY + 1 < grid[0].length) return grid[relativeX][relativeY + 1];\n      return undefined;\n    case \"W\":\n      if (relativeX - 1 >= 0) return grid[relativeX - 1][relativeY];\n      return undefined;\n    default:\n      return undefined;\n  }\n};\n\nconst setWallForCellAndNeighbour = (\n  cell: Cell,\n  direction: string,\n  grid: Cell[][],\n  addWalls: boolean = true\n) => {\n  cell.walls[direction] = addWalls;\n\n  const firstX = grid[0][0].x;\n  const firstY = grid[0][0].y;\n\n  const relativeX = Math.abs(firstX - cell.x);\n  const relativeY = Math.abs(firstY - cell.y);\n  // console.log([firstX, firstY, cell.x, cell.y, direction, relativeX, relativeY]);\n\n  if (getNeighbourDirections(grid, relativeX, relativeY).includes(direction)) {\n    const neighbour = getCellFromDirection(direction, grid, relativeX, relativeY);\n    if (neighbour) {\n      neighbour.walls[getOppositeDirection(direction)!] = addWalls;\n      console.log([cell.x, cell.y], direction, [neighbour.x, neighbour.y]);\n    }\n  } else {\n    console.log([cell.x, cell.y], direction, \"no neighbour\");\n  }\n};\n\nconst setWallForCollection = (\n  cells: Cell[],\n  direction: string,\n  grid: Cell[][],\n  addWalls: boolean\n) => {\n  cells.forEach((cell) =>\n    setWallForCellAndNeighbour(cell, direction, grid, addWalls)\n  );\n};\n\nconst createHorizontalWallWithGate = (\n  index: number,\n  grid: RecursiveDivisionCell[][]\n): void => {\n  const row = grid.map((col) => col[index]);\n  setWallForCollection(row, \"S\", grid, true);\n\n  const randomCell = row[getRandomIntInclusive(1, row.length - 2)];\n  setWallForCellAndNeighbour(randomCell, \"S\", grid, false);\n};\n\nconst createVerticalWallWithGate = (\n  index: number,\n  grid: RecursiveDivisionCell[][]\n): void => {\n  const column = grid[index];\n\n  setWallForCollection(column, \"E\", grid, true);\n\n  const randomCell = column[getRandomIntInclusive(1, column.length - 2)];\n  setWallForCellAndNeighbour(randomCell, \"E\", grid, false);\n};\n\nexport class Walls {\n  N: boolean;\n  E: boolean;\n  S: boolean;\n  W: boolean;\n  [key: string]: boolean;\n\n  constructor() {\n    this.N = true;\n    this.E = true;\n    this.S = true;\n    this.W = true;\n  }\n}\n\nexport class EmptyWalls extends Walls {\n  constructor() {\n    super();\n    this.N = false;\n    this.E = false;\n    this.S = false;\n    this.W = false;\n  }\n}\n\nexport class Cell {\n  x: number;\n  y: number;\n  walls: Walls;\n  visited: boolean;\n  backtracked: boolean;\n\n  constructor(x: number, y: number) {\n    this.x = x;\n    this.y = y;\n    this.walls = new Walls();\n    this.visited = false;\n    this.backtracked = false;\n  }\n}\n\nexport class RecursiveDivisionCell extends Cell {\n  currentArea: boolean;\n\n  constructor(x: number, y: number) {\n    super(x, y);\n    this.walls = new EmptyWalls();\n    this.currentArea = true;\n  }\n}\n\nexport class Grid {\n  height: number;\n  width: number;\n  grid: Cell[][];\n  stack: Cell[];\n  frames: Cell[][][];\n  algorithm: string;\n  [key: string]: any;\n\n  constructor(width: number, height: number) {\n    this.height = height <= 50 ? height : 50;\n    this.width = width <= 50 ? width : 50;\n    this.grid = [];\n    this.stack = [];\n    this.algorithm = \"grid\";\n\n    for (let x = 0; x < width; x++) {\n      let col = [];\n      for (let y = 0; y < height; y++) {\n        col.push(new Cell(x, y));\n      }\n      this.grid.push(col);\n    }\n\n    this.frames = [cloneDeep(this.grid)];\n  }\n\n  createFrame = (frame: Cell[][] = []) => {\n    if (frame.length < 1) frame = cloneDeep(this.grid);\n    this.frames.push(cloneDeep(frame));\n  };\n\n  generateMaze(cell: Cell) {}\n\n  draw(canvasContext: any, unitSize: number, step: number) {\n    // canvasContext.clearRect(0, 0, unitSize * this.width, unitSize * this.height);\n    canvasContext.beginPath();\n    this.frames[step].forEach((col) => {\n      canvasContext.strokeStyle = \"#800080\";\n      canvasContext.lineWidth = 5;\n      col.forEach((cell) => {\n        canvasContext.fillStyle = \"#FDA4BA\";\n        if (cell.visited && !cell.backtracked) {\n          canvasContext.fillRect(\n            cell.x * unitSize,\n            cell.y * unitSize,\n            unitSize + 1,\n            unitSize + 1\n          );\n        }\n        canvasContext.moveTo(cell.x * unitSize - 2.5, cell.y * unitSize);\n        if (cell.walls.N) {\n          canvasContext.lineTo(cell.x * unitSize + unitSize, cell.y * unitSize);\n        } else {\n          canvasContext.moveTo(cell.x * unitSize + unitSize, cell.y * unitSize);\n        }\n        if (cell.walls.E) {\n          canvasContext.lineTo(\n            cell.x * unitSize + unitSize,\n            cell.y * unitSize + unitSize\n          );\n        } else {\n          canvasContext.moveTo(\n            cell.x * unitSize + unitSize,\n            cell.y * unitSize + unitSize\n          );\n        }\n        if (cell.walls.S) {\n          canvasContext.lineTo(cell.x * unitSize, cell.y * unitSize + unitSize);\n        } else {\n          canvasContext.moveTo(cell.x * unitSize, cell.y * unitSize + unitSize);\n        }\n        if (cell.walls.W) {\n          canvasContext.lineTo(cell.x * unitSize, cell.y * unitSize);\n        } else {\n          canvasContext.moveTo(cell.x * unitSize, cell.y * unitSize);\n        }\n      });\n    });\n    canvasContext.stroke();\n\n    canvasContext.beginPath();\n    canvasContext.lineJoin = \"round\";\n    canvasContext.lineWidth = 10;\n    canvasContext.rect(0, 0, this.width * unitSize, this.height * unitSize);\n    canvasContext.stroke();\n\n    canvasContext.beginPath();\n    canvasContext.lineWidth = 10;\n    canvasContext.strokeStyle = \"#FFFFFF\";\n    canvasContext.moveTo(0, 5);\n    canvasContext.lineTo(0, unitSize - 2.5);\n    canvasContext.moveTo(this.width * unitSize, this.height * unitSize - 5);\n    canvasContext.lineTo(\n      this.width * unitSize,\n      this.height * unitSize - unitSize + 2.5\n    );\n    canvasContext.stroke();\n\n    canvasContext.beginPath();\n    canvasContext.lineWidth = 3;\n    canvasContext.fillStyle = \"#000000\";\n    canvasContext.moveTo(unitSize / 4, unitSize / 4);\n    canvasContext.lineTo(3 * (unitSize / 4), unitSize / 2);\n    canvasContext.lineTo(unitSize / 4, 3 * (unitSize / 4));\n    canvasContext.fill();\n\n    canvasContext.beginPath();\n    canvasContext.moveTo(\n      this.width * unitSize - 3 * (unitSize / 4),\n      this.height * unitSize - 3 * (unitSize / 4)\n    );\n    canvasContext.lineTo(\n      this.width * unitSize - unitSize / 4,\n      this.height * unitSize - unitSize / 2\n    );\n    canvasContext.lineTo(\n      this.width * unitSize - 3 * (unitSize / 4),\n      this.height * unitSize - unitSize / 4\n    );\n    canvasContext.fill();\n  }\n}\n\nexport class RecursiveBacktrackMaze extends Grid {\n  constructor(width: number, height: number) {\n    super(width, height);\n    const t0 = performance.now();\n    this.algorithm = \"recursiveBacktrackGenerate\";\n\n    this.generateMaze(this.grid[0][0]);\n\n    let lastFrame = this.frames.pop();\n    if (lastFrame) {\n      lastFrame[0][0].backtracked = true;\n      this.createFrame(cloneDeep(lastFrame));\n    }\n    const t1 = performance.now();\n    console.log(\"maze generated in: \", t1 - t0, \" milliseconds.\");\n  }\n\n  generateMaze = (cell: Cell) => {\n    cell.visited = true;\n    this.createFrame();\n\n    const directions = possibleMoves(cell, this.grid);\n    const direction = directions[getRandomIntInclusive(0, directions.length - 1)];\n    const nextCell = getCellFromDirection(direction, this.grid, cell.x, cell.y);\n\n    if (!nextCell && this.stack.length < 1) return;\n\n    if (nextCell) {\n      setWallForCellAndNeighbour(cell, direction, this.grid, false);\n      this.stack.push(cell);\n      this.generateMaze(nextCell);\n    } else {\n      cell.backtracked = true;\n      const oldCell = this.stack.pop();\n      if (oldCell) {\n        this.generateMaze(oldCell);\n      }\n    }\n  };\n\n  draw(canvasContext: any, unitSize: number, step: number) {\n    // canvasContext.clearRect(0, 0, unitSize * this.width, unitSize * this.height);\n    canvasContext.beginPath();\n    this.frames[step].forEach((col) => {\n      canvasContext.strokeStyle = \"#800080\";\n      canvasContext.lineWidth = 5;\n      col.forEach((cell) => {\n        canvasContext.fillStyle = \"#FDA4BA\";\n        if (cell.visited && !cell.backtracked) {\n          canvasContext.fillRect(\n            cell.x * unitSize,\n            cell.y * unitSize,\n            unitSize + 1,\n            unitSize + 1\n          );\n        }\n        canvasContext.moveTo(cell.x * unitSize - 2.5, cell.y * unitSize);\n        if (cell.walls.N) {\n          canvasContext.lineTo(cell.x * unitSize + unitSize, cell.y * unitSize);\n        } else {\n          canvasContext.moveTo(cell.x * unitSize + unitSize, cell.y * unitSize);\n        }\n        if (cell.walls.E) {\n          canvasContext.lineTo(\n            cell.x * unitSize + unitSize,\n            cell.y * unitSize + unitSize\n          );\n        } else {\n          canvasContext.moveTo(\n            cell.x * unitSize + unitSize,\n            cell.y * unitSize + unitSize\n          );\n        }\n        if (cell.walls.S) {\n          canvasContext.lineTo(cell.x * unitSize, cell.y * unitSize + unitSize);\n        } else {\n          canvasContext.moveTo(cell.x * unitSize, cell.y * unitSize + unitSize);\n        }\n        if (cell.walls.W) {\n          canvasContext.lineTo(cell.x * unitSize, cell.y * unitSize);\n        } else {\n          canvasContext.moveTo(cell.x * unitSize, cell.y * unitSize);\n        }\n      });\n    });\n    canvasContext.stroke();\n\n    canvasContext.beginPath();\n    canvasContext.lineJoin = \"round\";\n    canvasContext.lineWidth = 10;\n    canvasContext.rect(0, 0, this.width * unitSize, this.height * unitSize);\n    canvasContext.stroke();\n\n    canvasContext.beginPath();\n    canvasContext.lineWidth = 10;\n    canvasContext.strokeStyle = \"#FFFFFF\";\n    canvasContext.moveTo(0, 5);\n    canvasContext.lineTo(0, unitSize - 2.5);\n    canvasContext.moveTo(this.width * unitSize, this.height * unitSize - 5);\n    canvasContext.lineTo(\n      this.width * unitSize,\n      this.height * unitSize - unitSize + 2.5\n    );\n    canvasContext.stroke();\n\n    canvasContext.beginPath();\n    canvasContext.lineWidth = 3;\n    canvasContext.fillStyle = \"#000000\";\n    canvasContext.moveTo(unitSize / 4, unitSize / 4);\n    canvasContext.lineTo(3 * (unitSize / 4), unitSize / 2);\n    canvasContext.lineTo(unitSize / 4, 3 * (unitSize / 4));\n    canvasContext.fill();\n\n    canvasContext.beginPath();\n    canvasContext.moveTo(\n      this.width * unitSize - 3 * (unitSize / 4),\n      this.height * unitSize - 3 * (unitSize / 4)\n    );\n    canvasContext.lineTo(\n      this.width * unitSize - unitSize / 4,\n      this.height * unitSize - unitSize / 2\n    );\n    canvasContext.lineTo(\n      this.width * unitSize - 3 * (unitSize / 4),\n      this.height * unitSize - unitSize / 4\n    );\n    canvasContext.fill();\n  }\n}\n\nexport class RecursiveDivisionMaze extends Grid {\n  grid: RecursiveDivisionCell[][];\n  frames: RecursiveDivisionCell[][][];\n\n  constructor(width: number, height: number) {\n    super(width, height);\n    const t0 = performance.now();\n    this.algorithm = \"recursiveDivisionGenerate\";\n    this.grid = [];\n\n    // replace Cells with RecursiveDivisionCells (they have no walls)\n    for (let x = 0; x < width; x++) {\n      let col = [];\n      for (let y = 0; y < height; y++) {\n        col.push(new RecursiveDivisionCell(x, y));\n      }\n      this.grid.push(col);\n    }\n\n    //adding W, E, N, S perimeter walls\n    let topRow: RecursiveDivisionCell[] = [];\n    let botRow: RecursiveDivisionCell[] = [];\n    this.grid.forEach((col) => {\n      topRow.push(col[0]);\n      botRow.push(col[col.length - 1]);\n    });\n    setWallForCollection(topRow, \"N\", this.grid, true);\n    setWallForCollection(botRow, \"S\", this.grid, true);\n    setWallForCollection(this.grid[0], \"W\", this.grid, true);\n    setWallForCollection(this.grid[this.grid.length - 1], \"E\", this.grid, true);\n\n    this.frames = [this.grid];\n\n    this.generateMaze();\n\n    const t1 = performance.now();\n    console.log(\"maze generated in: \", t1 - t0, \" milliseconds.\");\n  }\n\n  generateMaze = (): void => {\n    const recusiveDivisionGeneration = (grid: RecursiveDivisionCell[][]) => {\n      let width: number;\n      let height: number;\n      let verticalSpace: boolean;\n\n      width = grid.length;\n      height = grid[0].length;\n      verticalSpace = width < height;\n\n      //exit condition to ensure we don't have an endless loop, also controls size of final rooms\n      if (width <= 1 || height <= 1) return;\n\n      this.grid.forEach((col) => col.forEach((cell) => (cell.currentArea = false)));\n      grid.forEach((col) => col.forEach((cell) => (cell.currentArea = true)));\n      this.createFrame();\n\n      if (verticalSpace) {\n        const index = getRandomIntInclusive(0, height - 2);\n\n        createHorizontalWallWithGate(index, grid);\n        this.createFrame();\n\n        //split and recurse\n        let half1: RecursiveDivisionCell[][] = [];\n        let half2: RecursiveDivisionCell[][] = [];\n\n        grid.forEach((col) => {\n          half1.push(col.slice(0, index + 1));\n          half2.push(col.slice(index + 1));\n        });\n        if (!!half1[0].length) recusiveDivisionGeneration(half1);\n        if (!!half2[0].length) recusiveDivisionGeneration(half2);\n      } else {\n        const index = getRandomIntInclusive(0, width - 2);\n\n        createVerticalWallWithGate(index, grid);\n        this.createFrame();\n\n        const half1 = grid.slice(0, index + 1);\n        const half2 = grid.slice(index + 1);\n        if (!!half1.length) recusiveDivisionGeneration(half1);\n        if (!!half2.length) recusiveDivisionGeneration(half2);\n      }\n    };\n\n    this.frames = [this.grid];\n    recusiveDivisionGeneration(this.grid);\n    this.grid.forEach((col) => col.forEach((cell) => (cell.currentArea = false)));\n    this.frames.push(cloneDeep(this.grid));\n  };\n\n  draw = (canvasContext: any, unitSize: number, step: number) => {\n    // canvasContext.clearRect(0, 0, unitSize * this.width, unitSize * this.height);\n    canvasContext.beginPath();\n\n    if (!this.frames[step]) return;\n\n    this.frames[step].forEach((col) => {\n      canvasContext.strokeStyle = \"#800080\";\n      canvasContext.lineWidth = 5;\n      col.forEach((cell) => {\n        canvasContext.fillStyle = \"#FDA4BA\";\n        if (cell.currentArea) {\n          canvasContext.fillRect(\n            cell.x * unitSize,\n            cell.y * unitSize,\n            unitSize + 1,\n            unitSize + 1\n          );\n        }\n        canvasContext.moveTo(cell.x * unitSize - 2.5, cell.y * unitSize);\n        if (cell.walls.N) {\n          canvasContext.lineTo(cell.x * unitSize + unitSize, cell.y * unitSize);\n        } else {\n          canvasContext.moveTo(cell.x * unitSize + unitSize, cell.y * unitSize);\n        }\n        if (cell.walls.E) {\n          canvasContext.lineTo(\n            cell.x * unitSize + unitSize,\n            cell.y * unitSize + unitSize\n          );\n        } else {\n          canvasContext.moveTo(\n            cell.x * unitSize + unitSize,\n            cell.y * unitSize + unitSize\n          );\n        }\n        if (cell.walls.S) {\n          canvasContext.lineTo(cell.x * unitSize, cell.y * unitSize + unitSize);\n        } else {\n          canvasContext.moveTo(cell.x * unitSize, cell.y * unitSize + unitSize);\n        }\n        if (cell.walls.W) {\n          canvasContext.lineTo(cell.x * unitSize, cell.y * unitSize);\n        } else {\n          canvasContext.moveTo(cell.x * unitSize, cell.y * unitSize);\n        }\n      });\n    });\n    canvasContext.stroke();\n\n    canvasContext.beginPath();\n    canvasContext.lineJoin = \"round\";\n    canvasContext.lineWidth = 10;\n    canvasContext.rect(0, 0, this.width * unitSize, this.height * unitSize);\n    canvasContext.stroke();\n\n    canvasContext.beginPath();\n    canvasContext.lineWidth = 10;\n    canvasContext.strokeStyle = \"#FFFFFF\";\n    canvasContext.moveTo(0, 5);\n    canvasContext.lineTo(0, unitSize - 2.5);\n    canvasContext.moveTo(this.width * unitSize, this.height * unitSize - 5);\n    canvasContext.lineTo(\n      this.width * unitSize,\n      this.height * unitSize - unitSize + 2.5\n    );\n    canvasContext.stroke();\n\n    canvasContext.beginPath();\n    canvasContext.lineWidth = 3;\n    canvasContext.fillStyle = \"#000000\";\n    canvasContext.moveTo(unitSize / 4, unitSize / 4);\n    canvasContext.lineTo(3 * (unitSize / 4), unitSize / 2);\n    canvasContext.lineTo(unitSize / 4, 3 * (unitSize / 4));\n    canvasContext.fill();\n\n    canvasContext.beginPath();\n    canvasContext.moveTo(\n      this.width * unitSize - 3 * (unitSize / 4),\n      this.height * unitSize - 3 * (unitSize / 4)\n    );\n    canvasContext.lineTo(\n      this.width * unitSize - unitSize / 4,\n      this.height * unitSize - unitSize / 2\n    );\n    canvasContext.lineTo(\n      this.width * unitSize - 3 * (unitSize / 4),\n      this.height * unitSize - unitSize / 4\n    );\n    canvasContext.fill();\n  };\n}\n\n// /*\n// All the above algorithms have biases of various sorts: depth-first search is biased toward long corridors, while Kruskal's/Prim's algorithms are biased toward many short dead ends. Wilson's algorithm,[1] on the other hand, generates an unbiased sample from the uniform distribution over all mazes, using loop-erased random walks.\n\n// We begin the algorithm by initializing the maze with one cell chosen arbitrarily. Then we start at a new cell chosen arbitrarily, and perform a random walk until we reach a cell already in the mazeâ€”however, if at any point the random walk reaches its own path, forming a loop, we erase the loop from the path before proceeding. When the path reaches the maze, we add it to the maze. Then we perform another loop-erased random walk from another arbitrary starting cell, repeating until all cells have been filled.\n\n// This procedure remains unbiased no matter which method we use to arbitrarily choose starting cells. So we could always choose the first unfilled cell in (say) left-to-right, top-to-bottom order for simplicity.*/\n","import React, { useRef, useEffect, useState } from \"react\";\nimport {\n  Grid,\n  RecursiveBacktrackMaze,\n} from \"../../../service/mazeGenerator.service\";\nimport { DijkstraSolve } from \"../../../service/mazeSolver.service\";\n\ntype CanvasProps = {\n  maze: Grid | RecursiveBacktrackMaze | DijkstraSolve;\n  delayBetweenFrames: number;\n};\n\nconst Canvas = ({ maze, delayBetweenFrames }: CanvasProps) => {\n  const canvasRef = useRef(null);\n  const [step, setStep] = useState(0);\n  const [measured, setMeasured] = useState(false);\n  const [unitSize, setUnitSize] = useState(1);\n  const [context, setContext] = useState(\n    document.createElement(\"canvas\").getContext(\"2d\")\n  );\n\n  useEffect(() => {\n    setStep(0);\n    const canvas: any = canvasRef.current;\n    const tmpContext = canvas.getContext(\"2d\");\n    const parentDiv = canvas.parentElement;\n    if (!measured) {\n      tmpContext.canvas.width = parentDiv?.offsetWidth;\n      tmpContext.canvas.height = parentDiv?.offsetHeight;\n      let tempUnitSize = 1;\n      while (\n        tempUnitSize * maze.height < tmpContext.canvas.height - 50 &&\n        tempUnitSize * maze.width < tmpContext.canvas.width - 50\n      ) {\n        tempUnitSize += 1;\n      }\n      setUnitSize(tempUnitSize);\n      setMeasured(true);\n      tmpContext.translate(5, 5);\n      setContext(tmpContext);\n    }\n  }, [maze, measured]);\n\n  useEffect(() => {\n    if (!context) throw new Error(\"No context\");\n\n    context.clearRect(\n      0,\n      0,\n      maze.width * unitSize + 300,\n      maze.height * unitSize + 100\n    );\n    context.font = \"20px Roboto\";\n    context.fillText(\n      `${step + 1} / ${maze.frames.length}`,\n      0,\n      maze.height * unitSize + 30\n    );\n    maze.draw(context, unitSize, step);\n\n    setTimeout(() => {\n      if (step + 1 < maze.frames.length) setStep(step + 1);\n    }, delayBetweenFrames);\n  }, [step, context, maze, unitSize, delayBetweenFrames]);\n\n  return <canvas ref={canvasRef} />;\n};\n\nexport default Canvas;\n","import { Walls, Cell, Grid, RecursiveDivisionCell } from \"./mazeGenerator.service\";\nimport { cloneDeep } from \"lodash\";\n\nclass CellForSolving extends Cell {\n  visited: boolean;\n  walls: Walls;\n\n  constructor(cell: Cell) {\n    super(cell.x, cell.y);\n    this.visited = false;\n    this.walls = cell.walls;\n  }\n}\n\nclass DijkstraCell extends CellForSolving {\n  distanceFromSource: number;\n  moveCost: number;\n  onPath: boolean;\n\n  constructor(cell: Cell) {\n    super(cell);\n    this.distanceFromSource = Infinity;\n    this.moveCost = 1;\n    this.onPath = false;\n  }\n\n  setDistanceFromSource(distance: number) {\n    this.distanceFromSource = distance;\n  }\n}\n\nexport class DijkstraSolve extends Grid {\n  grid: DijkstraCell[][];\n  frames: DijkstraCell[][][];\n\n  constructor(maze: Grid) {\n    super(maze.width, maze.height);\n    this.frames = [];\n    this.algorithm = \"DijkstraSolve\";\n\n    this.grid = maze.grid.map((row: RecursiveDivisionCell[] | Cell[]) => {\n      return row.map((cell: RecursiveDivisionCell | Cell) => {\n        return new DijkstraCell(cell);\n      });\n    });\n\n    this.solve();\n  }\n\n  getUnvisitedNeighbours = (cell: DijkstraCell): DijkstraCell[] => {\n    let allMoves = [\"N\", \"E\", \"S\", \"W\"];\n    let cellWalls: string[] = [];\n\n    Object.entries(cell.walls).forEach(([key, value]) => {\n      if (value) cellWalls.push(key);\n    });\n\n    const cellFromDirection = (direction: string): DijkstraCell | null => {\n      switch (direction) {\n        case \"N\":\n          if (!this.grid[cell.x][cell.y - 1]?.visited)\n            return this.grid[cell.x][cell.y - 1];\n          return null;\n        case \"E\":\n          if (!this.grid[cell.x + 1][cell.y]?.visited)\n            return this.grid[cell.x + 1][cell.y];\n          return null;\n        case \"S\":\n          if (!this.grid[cell.x][cell.y + 1]?.visited)\n            return this.grid[cell.x][cell.y + 1];\n          return null;\n        case \"W\":\n          if (!this.grid[cell.x - 1][cell.y]?.visited)\n            return this.grid[cell.x - 1][cell.y];\n          return null;\n        default:\n          return null;\n      }\n    };\n\n    const isCell = (candidate: any): candidate is DijkstraCell => {\n      if (candidate instanceof DijkstraCell) return true;\n      return false;\n    };\n\n    const cellMoves = allMoves\n      .filter((n) => !cellWalls.includes(n))\n      .map((move) => cellFromDirection(move));\n    const validMoves: DijkstraCell[] = cellMoves.filter(isCell)!;\n\n    return validMoves;\n  };\n\n  getBestPathNeighbor(cell: DijkstraCell) {\n    let allMoves = [\"N\", \"E\", \"S\", \"W\"];\n    let cellWalls: string[] = [];\n\n    Object.entries(cell.walls).forEach(([key, value]) => {\n      if (value) cellWalls.push(key);\n    });\n\n    const cellFromDirection = (direction: string): DijkstraCell | null => {\n      switch (direction) {\n        case \"N\":\n          if (!this.grid[cell.x][cell.y - 1]?.onPath)\n            return this.grid[cell.x][cell.y - 1];\n          return null;\n        case \"E\":\n          if (!this.grid[cell.x + 1][cell.y]?.onPath)\n            return this.grid[cell.x + 1][cell.y];\n          return null;\n        case \"S\":\n          if (!this.grid[cell.x][cell.y + 1]?.onPath)\n            return this.grid[cell.x][cell.y + 1];\n          return null;\n        case \"W\":\n          if (!this.grid[cell.x - 1][cell.y]?.onPath)\n            return this.grid[cell.x - 1][cell.y];\n          return null;\n        default:\n          return null;\n      }\n    };\n\n    const isCell = (candidate: any): candidate is DijkstraCell => {\n      if (candidate instanceof DijkstraCell) return true;\n      return false;\n    };\n\n    const cellMoves = allMoves\n      .filter((n) => !cellWalls.includes(n))\n      .map((move) => cellFromDirection(move));\n    const validMoves: DijkstraCell[] = cellMoves.filter(isCell)!;\n\n    return validMoves.reduce((lowest, cell) =>\n      lowest.distanceFromSource < cell.distanceFromSource ? lowest : cell\n    );\n  }\n\n  getAllNodes = (): DijkstraCell[] => {\n    let nodes: DijkstraCell[] = [];\n    for (let row of this.grid) {\n      for (let cell of row) {\n        nodes.push(cell);\n      }\n    }\n    return nodes;\n  };\n\n  updateNeighbourDistances = (currentCell: DijkstraCell) => {\n    const updateDistance = (currentCell: DijkstraCell, targetCell: DijkstraCell) => {\n      targetCell.distanceFromSource =\n        currentCell.distanceFromSource + targetCell.moveCost;\n    };\n\n    const neighbours = this.getUnvisitedNeighbours(currentCell);\n    neighbours.forEach((cell) => {\n      updateDistance(currentCell, cell);\n    });\n  };\n\n  solve = () => {\n    const sortNodesByDistance = (nodeList: DijkstraCell[]) => {\n      return nodeList.sort(\n        (firstNode, secondNode) =>\n          firstNode.distanceFromSource - secondNode.distanceFromSource\n      );\n    };\n\n    const t0 = performance.now();\n\n    const exitCell = this.grid[this.width - 1][this.height - 1];\n    const unvisitedCells = this.getAllNodes();\n    const startCell = this.grid[0][0];\n    startCell.distanceFromSource = 0;\n\n    while (!!unvisitedCells.length) {\n      sortNodesByDistance(unvisitedCells);\n      const currentCell = unvisitedCells.shift();\n\n      if (currentCell === undefined) break;\n      if (currentCell.distanceFromSource === Infinity) break;\n      if (currentCell === exitCell) break;\n\n      currentCell.visited = true;\n\n      this.updateNeighbourDistances(currentCell);\n      this.frames.push(cloneDeep(this.grid));\n    }\n\n    let currentCell = exitCell;\n\n    while (!(currentCell === startCell)) {\n      currentCell.onPath = true;\n      const nextCell = this.getBestPathNeighbor(currentCell);\n      this.frames.push(cloneDeep(this.grid));\n      currentCell = nextCell;\n    }\n\n    startCell.onPath = true;\n    this.frames.push(cloneDeep(this.grid));\n\n    const t1 = performance.now();\n    console.log(\"solved in:\", t1 - t0, \"milliseconds.\");\n  };\n\n  draw(canvasContext: any, unitSize: number, step: number) {\n    canvasContext.clearRect(0, 0, unitSize * this.width, unitSize * this.height);\n    if (this.frames[step] === undefined) return;\n    canvasContext.strokeStyle = \"#800080\";\n    canvasContext.lineWidth = 5;\n    canvasContext.beginPath();\n    this.frames[step].forEach((row) => {\n      row.forEach((cell) => {\n        if (cell.visited) {\n          canvasContext.fillStyle = \"#FDA4BA\";\n          canvasContext.fillRect(\n            cell.x * unitSize,\n            cell.y * unitSize,\n            unitSize + 1,\n            unitSize + 1\n          );\n        }\n\n        if (cell.onPath) {\n          canvasContext.fillStyle = \"#00BFFF\";\n          canvasContext.fillRect(\n            cell.x * unitSize,\n            cell.y * unitSize,\n            unitSize,\n            unitSize\n          );\n        }\n\n        canvasContext.moveTo(cell.x * unitSize - 2.5, cell.y * unitSize);\n        if (cell.walls.N) {\n          canvasContext.lineTo(cell.x * unitSize + unitSize, cell.y * unitSize);\n        } else {\n          canvasContext.moveTo(cell.x * unitSize + unitSize, cell.y * unitSize);\n        }\n        if (cell.walls.E) {\n          canvasContext.lineTo(\n            cell.x * unitSize + unitSize,\n            cell.y * unitSize + unitSize\n          );\n        } else {\n          canvasContext.moveTo(\n            cell.x * unitSize + unitSize,\n            cell.y * unitSize + unitSize\n          );\n        }\n        if (cell.walls.S) {\n          canvasContext.lineTo(cell.x * unitSize, cell.y * unitSize + unitSize);\n        } else {\n          canvasContext.moveTo(cell.x * unitSize, cell.y * unitSize + unitSize);\n        }\n        if (cell.walls.W) {\n          canvasContext.lineTo(cell.x * unitSize, cell.y * unitSize);\n        } else {\n          canvasContext.moveTo(cell.x * unitSize, cell.y * unitSize);\n        }\n      });\n    });\n    canvasContext.stroke();\n\n    canvasContext.beginPath();\n    canvasContext.lineJoin = \"round\";\n    canvasContext.lineWidth = 10;\n    canvasContext.rect(0, 0, this.width * unitSize, this.height * unitSize);\n    canvasContext.stroke();\n\n    canvasContext.beginPath();\n    canvasContext.lineWidth = 10;\n    canvasContext.strokeStyle = \"#FFFFFF\";\n    canvasContext.moveTo(0, 5);\n    canvasContext.lineTo(0, unitSize - 2.5);\n    canvasContext.moveTo(this.width * unitSize, this.height * unitSize - 5);\n    canvasContext.lineTo(\n      this.width * unitSize,\n      this.height * unitSize - unitSize + 2.5\n    );\n    canvasContext.stroke();\n\n    canvasContext.beginPath();\n    canvasContext.lineWidth = 3;\n    canvasContext.fillStyle = \"#000000\";\n    canvasContext.moveTo(unitSize / 4, unitSize / 4);\n    canvasContext.lineTo(3 * (unitSize / 4), unitSize / 2);\n    canvasContext.lineTo(unitSize / 4, 3 * (unitSize / 4));\n    canvasContext.fill();\n\n    canvasContext.beginPath();\n    canvasContext.moveTo(\n      this.width * unitSize - 3 * (unitSize / 4),\n      this.height * unitSize - 3 * (unitSize / 4)\n    );\n    canvasContext.lineTo(\n      this.width * unitSize - unitSize / 4,\n      this.height * unitSize - unitSize / 2\n    );\n    canvasContext.lineTo(\n      this.width * unitSize - 3 * (unitSize / 4),\n      this.height * unitSize - unitSize / 4\n    );\n    canvasContext.fill();\n  }\n}\n","import Maze from \"./Maze\";\n\nexport default Maze","import React, { useState } from \"react\";\nimport styles from \"./Maze.module.scss\";\nimport {\n  Grid,\n  RecursiveBacktrackMaze,\n  RecursiveDivisionMaze,\n} from \"../../service/mazeGenerator.service\";\nimport Canvas from \"./Canvas/Canvas\";\nimport { cloneDeep } from \"lodash\";\nimport { DijkstraSolve } from \"../../service/mazeSolver.service\";\n\nconst Maze = () => {\n  const [dimensions] = useState({ width: 15, height: 10 });\n  const [maze, setMaze] = useState(new Grid(dimensions.width, dimensions.height));\n  const [delayBetweenFrames, setFrameDelay] = useState(1);\n\n  const handleChange = (event: any): void => {\n    let newDelay = Number(event.target.value);\n    newDelay = Math.max(newDelay, 0);\n    newDelay = Math.min(newDelay, 2000);\n    setFrameDelay(newDelay);\n  };\n\n  return (\n    <div className={styles.mazeContainer}>\n      <div className={styles.maze} id=\"maze\">\n        <Canvas maze={maze} delayBetweenFrames={delayBetweenFrames} />\n        <div>\n          <button\n            onClick={() => {\n              setMaze(cloneDeep(maze));\n            }}\n          >\n            Re-run\n          </button>\n          <button\n            onClick={() => {\n              setMaze(\n                new RecursiveBacktrackMaze(dimensions.width, dimensions.height)\n              );\n            }}\n          >\n            New Backtrack maze\n          </button>\n          <button\n            onClick={() => {\n              setMaze(\n                new RecursiveDivisionMaze(dimensions.width, dimensions.height)\n              );\n            }}\n          >\n            New Division maze\n          </button>\n          <button\n            onClick={() => {\n              setMaze(new DijkstraSolve(maze));\n            }}\n          >\n            Solve\n          </button>\n          Interval:{\" \"}\n          <input\n            type=\"number\"\n            min=\"1\"\n            max=\"1000\"\n            step=\"10\"\n            defaultValue={delayBetweenFrames}\n            onChange={handleChange}\n          />{\" \"}\n          ms.\n        </div>\n      </div>\n    </div>\n  );\n};\n\nexport default Maze;\n","import React from 'react';\nimport './App.css';\nimport SelectionBar from './components/SelectionBar';\nimport Maze from './components/Maze';\n\nfunction App() {\n  return (\n    <div className='App'>\n    <SelectionBar />\n    <Maze />\n    </div>\n  );\n}\n\nexport default App;\n","import { ReportHandler } from 'web-vitals';\n\nconst reportWebVitals = (onPerfEntry?: ReportHandler) => {\n  if (onPerfEntry && onPerfEntry instanceof Function) {\n    import('web-vitals').then(({ getCLS, getFID, getFCP, getLCP, getTTFB }) => {\n      getCLS(onPerfEntry);\n      getFID(onPerfEntry);\n      getFCP(onPerfEntry);\n      getLCP(onPerfEntry);\n      getTTFB(onPerfEntry);\n    });\n  }\n};\n\nexport default reportWebVitals;\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport reportWebVitals from './reportWebVitals';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n// If you want to start measuring performance in your app, pass a function\n// to log results (for example: reportWebVitals(console.log))\n// or send to an analytics endpoint. Learn more: https://bit.ly/CRA-vitals\nreportWebVitals();\n"],"sourceRoot":""}