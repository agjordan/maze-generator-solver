{"version":3,"sources":["components/Maze/Maze.module.scss","components/SelectionBar/SelectionBar.module.scss","components/SelectionBar/index.ts","components/SelectionBar/SelectionBar.tsx","service/mazeGenerator.service.ts","components/Maze/Canvas/Canvas.tsx","service/mazeSolver.service.ts","components/Maze/index.ts","components/Maze/Maze.tsx","App.tsx","reportWebVitals.ts","index.tsx"],"names":["module","exports","SelectionBar","className","styles","selectionBar","getUnvisitedDirections","cell","grid","moves","y","x","visited","push","length","getNeighbourDirections","relativeX","relativeY","directions","getOppositeDirection","direction","getRandomIntInclusive","min","max","Math","ceil","floor","random","getCellFromDirection","setWallForCellAndNeighbour","addWalls","walls","firstX","firstY","abs","includes","neighbour","setWallForCollection","cells","forEach","createHorizontalWallWithGate","index","row","map","col","randomCell","createVerticalWallWithGate","column","Walls","N","E","S","W","this","EmptyWalls","Cell","backtracked","RecursiveDivisionCell","currentArea","Grid","width","height","drawEveryFrame","stack","frames","algorithm","createFrame","frame","cloneDeep","generateGrid","generateMaze","canvasContext","unitSize","step","beginPath","strokeStyle","lineWidth","fillStyle","fillRect","moveTo","lineTo","stroke","lineJoin","rect","fill","RecursiveBacktrackMaze","nextCell","oldCell","pop","t0","performance","now","t1","console","log","RecursiveDivisionMaze","recusiveDivisionGeneration","verticalSpace","half1","half2","slice","draw","topRow","botRow","Canvas","maze","delayBetweenFrames","canvasRef","useRef","useState","setStep","measured","setMeasured","setUnitSize","document","createElement","getContext","context","setContext","useEffect","canvas","current","tmpContext","parentDiv","parentElement","offsetWidth","offsetHeight","tempUnitSize","translate","Error","clearRect","font","fillText","setTimeout","ref","DijkstraCell","distanceFromSource","moveCost","onPath","Infinity","DijkstraSolve","animate","mazeCells","updateNeighbourDistances","currentCell","cellWalls","Object","entries","key","filter","n","move","getUnvisitedCellFromDirection","candidate","getUnvisitedNeighbours","targetCell","updateDistance","solve","exitCell","unvisitedCells","getAllCells","startCell","sort","firstNode","secondNode","shift","undefined","getClosestVisitableNeighbour","error","alert","getCellWalls","cellNotOnPathFromDirection","reduce","lowest","Maze","dimensions","setMaze","setFrameDelay","setAnimate","solveButtonRef","backtrackButtonRef","divisionButtonRef","mazeContainer","id","onClick","setAttribute","removeAttribute","type","defaultValue","onChange","event","newDelay","Number","target","value","name","defaultChecked","App","reportWebVitals","onPerfEntry","Function","then","getCLS","getFID","getFCP","getLCP","getTTFB","ReactDOM","render","StrictMode","getElementById"],"mappings":"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","file":"static/js/main.84a5a016.chunk.js","sourcesContent":["// extracted by mini-css-extract-plugin\nmodule.exports = {\"mazeContainer\":\"Maze_mazeContainer__3Exuk\",\"maze\":\"Maze_maze__2NaIp\"};","// extracted by mini-css-extract-plugin\nmodule.exports = {\"selectionBar\":\"SelectionBar_selectionBar__14QJ9\"};","import SelectionBar from \"./SelectionBar\";\n\nexport default SelectionBar","import React from 'react'\nimport styles from './SelectionBar.module.scss'\n\nconst SelectionBar = () => {\n    return (\n        <div className={styles.selectionBar}>\n            <h1>Maze Generator</h1>\n        </div>\n    )\n}\n\nexport default SelectionBar\n","import { cloneDeep } from \"lodash\";\n\nconst getUnvisitedDirections = (cell: Cell, grid: Cell[][]): string[] => {\n  let moves = [];\n  if (cell.y - 1 >= 0 && !grid[cell.x][cell.y - 1].visited) moves.push(\"N\");\n  if (cell.x + 1 < grid.length && !grid[cell.x + 1][cell.y].visited) moves.push(\"E\");\n  if (cell.y + 1 < grid[0].length && !grid[cell.x][cell.y + 1].visited)\n    moves.push(\"S\");\n  if (cell.x - 1 >= 0 && !grid[cell.x - 1][cell.y].visited) moves.push(\"W\");\n  return moves;\n};\n\nconst getNeighbourDirections = (\n  grid: Cell[][],\n  relativeX: number,\n  relativeY: number\n) => {\n  let directions = [];\n  if (relativeY - 1 >= 0) directions.push(\"N\");\n  if (relativeX + 1 < grid.length) directions.push(\"E\");\n  if (relativeY + 1 < grid[0].length) directions.push(\"S\");\n  if (relativeX - 1 >= 0) directions.push(\"W\");\n  return directions;\n};\n\nconst getOppositeDirection = (direction: string): string | null => {\n  switch (direction) {\n    case \"N\":\n      return \"S\";\n    case \"E\":\n      return \"W\";\n    case \"S\":\n      return \"N\";\n    case \"W\":\n      return \"E\";\n    default:\n      return null;\n  }\n};\n\nconst getRandomIntInclusive = (min: number, max: number): number => {\n  min = Math.ceil(min);\n  max = Math.floor(max);\n  return Math.floor(Math.random() * (max - min + 1) + min);\n};\n\nconst getCellFromDirection = (\n  direction: string,\n  grid: Cell[][],\n  relativeX: number,\n  relativeY: number\n): Cell | undefined => {\n  switch (direction) {\n    case \"N\":\n      if (relativeY - 1 >= 0) return grid[relativeX][relativeY - 1];\n      return undefined;\n    case \"E\":\n      if (relativeX + 1 < grid.length) return grid[relativeX + 1][relativeY];\n      return undefined;\n    case \"S\":\n      if (relativeY + 1 < grid[0].length) return grid[relativeX][relativeY + 1];\n      return undefined;\n    case \"W\":\n      if (relativeX - 1 >= 0) return grid[relativeX - 1][relativeY];\n      return undefined;\n    default:\n      return undefined;\n  }\n};\n\nconst setWallForCellAndNeighbour = (\n  cell: Cell,\n  direction: string,\n  grid: Cell[][],\n  addWalls: boolean = true\n) => {\n  cell.walls[direction] = addWalls;\n\n  const firstX = grid[0][0].x;\n  const firstY = grid[0][0].y;\n\n  const relativeX = Math.abs(firstX - cell.x);\n  const relativeY = Math.abs(firstY - cell.y);\n\n  if (getNeighbourDirections(grid, relativeX, relativeY).includes(direction)) {\n    const neighbour = getCellFromDirection(direction, grid, relativeX, relativeY);\n    if (neighbour) neighbour.walls[getOppositeDirection(direction)!] = addWalls;\n  }\n};\n\nconst setWallForCollection = (\n  cells: Cell[],\n  direction: string,\n  grid: Cell[][],\n  addWalls: boolean\n) => {\n  cells.forEach((cell) =>\n    setWallForCellAndNeighbour(cell, direction, grid, addWalls)\n  );\n};\n\nconst createHorizontalWallWithGate = (\n  index: number,\n  grid: RecursiveDivisionCell[][]\n): void => {\n  const row = grid.map((col) => col[index]);\n  setWallForCollection(row, \"S\", grid, true);\n\n  const randomCell = row[getRandomIntInclusive(1, row.length - 1)];\n  setWallForCellAndNeighbour(randomCell, \"S\", grid, false);\n};\n\nconst createVerticalWallWithGate = (\n  index: number,\n  grid: RecursiveDivisionCell[][]\n): void => {\n  const column = grid[index];\n\n  setWallForCollection(column, \"E\", grid, true);\n\n  const randomCell = column[getRandomIntInclusive(1, column.length - 1)];\n  setWallForCellAndNeighbour(randomCell, \"E\", grid, false);\n};\n\nexport class Walls {\n  N: boolean;\n  E: boolean;\n  S: boolean;\n  W: boolean;\n  [key: string]: boolean;\n\n  constructor() {\n    this.N = true;\n    this.E = true;\n    this.S = true;\n    this.W = true;\n  }\n}\n\nexport class EmptyWalls extends Walls {\n  constructor() {\n    super();\n    this.N = false;\n    this.E = false;\n    this.S = false;\n    this.W = false;\n  }\n}\n\nexport class Cell {\n  x: number;\n  y: number;\n  walls: Walls;\n  visited: boolean;\n  backtracked: boolean;\n\n  constructor(x: number, y: number) {\n    this.x = x;\n    this.y = y;\n    this.walls = new Walls();\n    this.visited = false;\n    this.backtracked = false;\n  }\n}\n\nexport class RecursiveDivisionCell extends Cell {\n  currentArea: boolean;\n\n  constructor(x: number, y: number) {\n    super(x, y);\n    this.walls = new EmptyWalls();\n    this.currentArea = true;\n  }\n}\n\nexport class Grid {\n  height: number;\n  width: number;\n  grid: Cell[][];\n  stack: Cell[];\n  frames: Cell[][][];\n  algorithm: string;\n  drawEveryFrame: boolean;\n  [key: string]: any;\n\n  constructor(width: number, height: number, drawEveryFrame: boolean = true) {\n    this.height = height;\n    this.width = width;\n    this.grid = [];\n    this.stack = [];\n    this.algorithm = \"grid\";\n    this.drawEveryFrame = drawEveryFrame;\n\n    this.generateGrid();\n    this.frames = [cloneDeep(this.grid)];\n  }\n\n  createFrame = (frame: Cell[][] = []) => {\n    if (frame.length < 1) frame = this.grid;\n    if (this.drawEveryFrame) this.frames.push(cloneDeep(frame));\n  };\n\n  generateGrid = () => {\n    for (let x = 0; x < this.width; x++) {\n      let col = [];\n      for (let y = 0; y < this.height; y++) {\n        col.push(new Cell(x, y));\n      }\n      this.grid.push(col);\n    }\n  };\n\n  generateMaze = (cell: Cell) => {};\n\n  draw(canvasContext: any, unitSize: number, step: number) {\n    // canvasContext.clearRect(0, 0, unitSize * this.width, unitSize * this.height);\n    canvasContext.beginPath();\n    this.frames[step].forEach((col) => {\n      canvasContext.strokeStyle = \"#800080\";\n      canvasContext.lineWidth = 5;\n      col.forEach((cell) => {\n        canvasContext.fillStyle = \"#FDA4BA\";\n        if (cell.visited && !cell.backtracked) {\n          canvasContext.fillRect(\n            cell.x * unitSize,\n            cell.y * unitSize,\n            unitSize + 1,\n            unitSize + 1\n          );\n        }\n        canvasContext.moveTo(cell.x * unitSize - 2.5, cell.y * unitSize);\n        if (cell.walls.N) {\n          canvasContext.lineTo(cell.x * unitSize + unitSize, cell.y * unitSize);\n        } else {\n          canvasContext.moveTo(cell.x * unitSize + unitSize, cell.y * unitSize);\n        }\n        if (cell.walls.E) {\n          canvasContext.lineTo(\n            cell.x * unitSize + unitSize,\n            cell.y * unitSize + unitSize\n          );\n        } else {\n          canvasContext.moveTo(\n            cell.x * unitSize + unitSize,\n            cell.y * unitSize + unitSize\n          );\n        }\n        if (cell.walls.S) {\n          canvasContext.lineTo(cell.x * unitSize, cell.y * unitSize + unitSize);\n        } else {\n          canvasContext.moveTo(cell.x * unitSize, cell.y * unitSize + unitSize);\n        }\n        if (cell.walls.W) {\n          canvasContext.lineTo(cell.x * unitSize, cell.y * unitSize);\n        } else {\n          canvasContext.moveTo(cell.x * unitSize, cell.y * unitSize);\n        }\n      });\n    });\n    canvasContext.stroke();\n\n    canvasContext.beginPath();\n    canvasContext.lineJoin = \"round\";\n    canvasContext.lineWidth = 10;\n    canvasContext.rect(0, 0, this.width * unitSize, this.height * unitSize);\n    canvasContext.stroke();\n\n    canvasContext.beginPath();\n    canvasContext.lineWidth = 10;\n    canvasContext.strokeStyle = \"#FFFFFF\";\n    canvasContext.moveTo(0, 5);\n    canvasContext.lineTo(0, unitSize - 2.5);\n    canvasContext.moveTo(this.width * unitSize, this.height * unitSize - 5);\n    canvasContext.lineTo(\n      this.width * unitSize,\n      this.height * unitSize - unitSize + 2.5\n    );\n    canvasContext.stroke();\n\n    canvasContext.beginPath();\n    canvasContext.lineWidth = 3;\n    canvasContext.fillStyle = \"#000000\";\n    canvasContext.moveTo(unitSize / 4, unitSize / 4);\n    canvasContext.lineTo(3 * (unitSize / 4), unitSize / 2);\n    canvasContext.lineTo(unitSize / 4, 3 * (unitSize / 4));\n    canvasContext.fill();\n\n    canvasContext.beginPath();\n    canvasContext.moveTo(\n      this.width * unitSize - 3 * (unitSize / 4),\n      this.height * unitSize - 3 * (unitSize / 4)\n    );\n    canvasContext.lineTo(\n      this.width * unitSize - unitSize / 4,\n      this.height * unitSize - unitSize / 2\n    );\n    canvasContext.lineTo(\n      this.width * unitSize - 3 * (unitSize / 4),\n      this.height * unitSize - unitSize / 4\n    );\n    canvasContext.fill();\n  }\n}\n\nexport class RecursiveBacktrackMaze extends Grid {\n  constructor(width: number, height: number, drawEveryFrame: boolean = true) {\n    super(width, height, drawEveryFrame);\n    const t0 = performance.now();\n    this.algorithm = \"recursiveBacktrackGenerate\";\n\n    this.generateMaze(this.grid[0][0]);\n\n    this.grid[0][0].backtracked = true;\n    this.frames.push(cloneDeep(this.grid));\n    const t1 = performance.now();\n    console.log(\"maze generated in: \", t1 - t0, \" milliseconds.\");\n  }\n\n  generateMaze = (cell: Cell) => {\n    cell.visited = true;\n    this.createFrame();\n\n    const directions = getUnvisitedDirections(cell, this.grid);\n    const direction = directions[getRandomIntInclusive(0, directions.length - 1)];\n    const nextCell = getCellFromDirection(direction, this.grid, cell.x, cell.y);\n\n    if (!nextCell && this.stack.length < 1) return;\n\n    if (nextCell) {\n      setWallForCellAndNeighbour(cell, direction, this.grid, false);\n      this.stack.push(cell);\n      this.generateMaze(nextCell);\n    } else {\n      cell.backtracked = true;\n      const oldCell = this.stack.pop();\n      if (oldCell) {\n        this.generateMaze(oldCell);\n      }\n    }\n  };\n\n  draw(canvasContext: any, unitSize: number, step: number) {\n    if (!this.frames[step]) return;\n    canvasContext.beginPath();\n    this.frames[step].forEach((col) => {\n      canvasContext.strokeStyle = \"#800080\";\n      canvasContext.lineWidth = 5;\n      col.forEach((cell) => {\n        canvasContext.fillStyle = \"#FDA4BA\";\n        if (cell.visited && !cell.backtracked) {\n          canvasContext.fillRect(\n            cell.x * unitSize,\n            cell.y * unitSize,\n            unitSize + 1,\n            unitSize + 1\n          );\n        }\n        canvasContext.moveTo(cell.x * unitSize - 2.5, cell.y * unitSize);\n        if (cell.walls.N) {\n          canvasContext.lineTo(cell.x * unitSize + unitSize, cell.y * unitSize);\n        } else {\n          canvasContext.moveTo(cell.x * unitSize + unitSize, cell.y * unitSize);\n        }\n        if (cell.walls.E) {\n          canvasContext.lineTo(\n            cell.x * unitSize + unitSize,\n            cell.y * unitSize + unitSize\n          );\n        } else {\n          canvasContext.moveTo(\n            cell.x * unitSize + unitSize,\n            cell.y * unitSize + unitSize\n          );\n        }\n        if (cell.walls.S) {\n          canvasContext.lineTo(cell.x * unitSize, cell.y * unitSize + unitSize);\n        } else {\n          canvasContext.moveTo(cell.x * unitSize, cell.y * unitSize + unitSize);\n        }\n        if (cell.walls.W) {\n          canvasContext.lineTo(cell.x * unitSize, cell.y * unitSize);\n        } else {\n          canvasContext.moveTo(cell.x * unitSize, cell.y * unitSize);\n        }\n      });\n    });\n    canvasContext.stroke();\n\n    canvasContext.beginPath();\n    canvasContext.lineJoin = \"round\";\n    canvasContext.lineWidth = 10;\n    canvasContext.rect(0, 0, this.width * unitSize, this.height * unitSize);\n    canvasContext.stroke();\n\n    canvasContext.beginPath();\n    canvasContext.lineWidth = 10;\n    canvasContext.strokeStyle = \"#FFFFFF\";\n    canvasContext.moveTo(0, 5);\n    canvasContext.lineTo(0, unitSize - 2.5);\n    canvasContext.moveTo(this.width * unitSize, this.height * unitSize - 5);\n    canvasContext.lineTo(\n      this.width * unitSize,\n      this.height * unitSize - unitSize + 2.5\n    );\n    canvasContext.stroke();\n\n    canvasContext.beginPath();\n    canvasContext.lineWidth = 3;\n    canvasContext.fillStyle = \"#000000\";\n    canvasContext.moveTo(unitSize / 4, unitSize / 4);\n    canvasContext.lineTo(3 * (unitSize / 4), unitSize / 2);\n    canvasContext.lineTo(unitSize / 4, 3 * (unitSize / 4));\n    canvasContext.fill();\n\n    canvasContext.beginPath();\n    canvasContext.moveTo(\n      this.width * unitSize - 3 * (unitSize / 4),\n      this.height * unitSize - 3 * (unitSize / 4)\n    );\n    canvasContext.lineTo(\n      this.width * unitSize - unitSize / 4,\n      this.height * unitSize - unitSize / 2\n    );\n    canvasContext.lineTo(\n      this.width * unitSize - 3 * (unitSize / 4),\n      this.height * unitSize - unitSize / 4\n    );\n    canvasContext.fill();\n  }\n}\n\nexport class RecursiveDivisionMaze extends Grid {\n  grid: RecursiveDivisionCell[][];\n  frames: RecursiveDivisionCell[][][];\n\n  constructor(width: number, height: number, drawEveryFrame: boolean = true) {\n    super(width, height, drawEveryFrame);\n    const t0 = performance.now();\n    this.algorithm = \"recursiveDivisionGenerate\";\n    this.grid = [];\n\n    // replace Cells with RecursiveDivisionCells (they have no walls)\n    for (let x = 0; x < width; x++) {\n      let col = [];\n      for (let y = 0; y < height; y++) {\n        col.push(new RecursiveDivisionCell(x, y));\n      }\n      this.grid.push(col);\n    }\n\n    //adding W, E, N, S perimeter walls\n    let topRow: RecursiveDivisionCell[] = [];\n    let botRow: RecursiveDivisionCell[] = [];\n    this.grid.forEach((col) => {\n      topRow.push(col[0]);\n      botRow.push(col[col.length - 1]);\n    });\n    setWallForCollection(topRow, \"N\", this.grid, true);\n    setWallForCollection(botRow, \"S\", this.grid, true);\n    setWallForCollection(this.grid[0], \"W\", this.grid, true);\n    setWallForCollection(this.grid[this.grid.length - 1], \"E\", this.grid, true);\n\n    this.frames = [this.grid];\n\n    this.generateMaze();\n\n    const t1 = performance.now();\n    console.log(\"maze generated in: \", t1 - t0, \" milliseconds.\");\n  }\n\n  generateMaze = (): void => {\n    const recusiveDivisionGeneration = (grid: RecursiveDivisionCell[][]) => {\n      let width: number;\n      let height: number;\n      let verticalSpace: boolean;\n\n      width = grid.length;\n      height = grid[0].length;\n      verticalSpace = width < height;\n\n      //exit condition to ensure we don't have an endless loop, also controls size of final rooms\n      if (width <= 1 || height <= 1) return;\n\n      this.grid.forEach((col) => col.forEach((cell) => (cell.currentArea = false)));\n      grid.forEach((col) => col.forEach((cell) => (cell.currentArea = true)));\n      this.createFrame();\n\n      if (verticalSpace) {\n        const index = getRandomIntInclusive(0, height - 2);\n\n        createHorizontalWallWithGate(index, grid);\n        this.createFrame();\n\n        //split and recurse\n        let half1: RecursiveDivisionCell[][] = [];\n        let half2: RecursiveDivisionCell[][] = [];\n\n        grid.forEach((col) => {\n          half1.push(col.slice(0, index + 1));\n          half2.push(col.slice(index + 1));\n        });\n        if (!!half1[0].length) recusiveDivisionGeneration(half1);\n        if (!!half2[0].length) recusiveDivisionGeneration(half2);\n      } else {\n        const index = getRandomIntInclusive(0, width - 2);\n\n        createVerticalWallWithGate(index, grid);\n        this.createFrame();\n\n        const half1 = grid.slice(0, index + 1);\n        const half2 = grid.slice(index + 1);\n        if (!!half1.length) recusiveDivisionGeneration(half1);\n        if (!!half2.length) recusiveDivisionGeneration(half2);\n      }\n    };\n\n    this.frames = [this.grid];\n    recusiveDivisionGeneration(this.grid);\n    this.grid.forEach((col) => col.forEach((cell) => (cell.currentArea = false)));\n    this.createFrame();\n  };\n\n  draw = (canvasContext: any, unitSize: number, step: number) => {\n    // canvasContext.clearRect(0, 0, unitSize * this.width, unitSize * this.height);\n    canvasContext.beginPath();\n\n    if (!this.frames[step]) return;\n\n    this.frames[step].forEach((col) => {\n      canvasContext.strokeStyle = \"#800080\";\n      canvasContext.lineWidth = 5;\n      col.forEach((cell) => {\n        canvasContext.fillStyle = \"#FDA4BA\";\n        if (cell.currentArea) {\n          canvasContext.fillRect(\n            cell.x * unitSize,\n            cell.y * unitSize,\n            unitSize + 1,\n            unitSize + 1\n          );\n        }\n        canvasContext.moveTo(cell.x * unitSize - 2.5, cell.y * unitSize);\n        if (cell.walls.N) {\n          canvasContext.lineTo(cell.x * unitSize + unitSize, cell.y * unitSize);\n        } else {\n          canvasContext.moveTo(cell.x * unitSize + unitSize, cell.y * unitSize);\n        }\n        if (cell.walls.E) {\n          canvasContext.lineTo(\n            cell.x * unitSize + unitSize,\n            cell.y * unitSize + unitSize\n          );\n        } else {\n          canvasContext.moveTo(\n            cell.x * unitSize + unitSize,\n            cell.y * unitSize + unitSize\n          );\n        }\n        if (cell.walls.S) {\n          canvasContext.lineTo(cell.x * unitSize, cell.y * unitSize + unitSize);\n        } else {\n          canvasContext.moveTo(cell.x * unitSize, cell.y * unitSize + unitSize);\n        }\n        if (cell.walls.W) {\n          canvasContext.lineTo(cell.x * unitSize, cell.y * unitSize);\n        } else {\n          canvasContext.moveTo(cell.x * unitSize, cell.y * unitSize);\n        }\n      });\n    });\n    canvasContext.stroke();\n\n    canvasContext.beginPath();\n    canvasContext.lineJoin = \"round\";\n    canvasContext.lineWidth = 10;\n    canvasContext.rect(0, 0, this.width * unitSize, this.height * unitSize);\n    canvasContext.stroke();\n\n    canvasContext.beginPath();\n    canvasContext.lineWidth = 10;\n    canvasContext.strokeStyle = \"#FFFFFF\";\n    canvasContext.moveTo(0, 5);\n    canvasContext.lineTo(0, unitSize - 2.5);\n    canvasContext.moveTo(this.width * unitSize, this.height * unitSize - 5);\n    canvasContext.lineTo(\n      this.width * unitSize,\n      this.height * unitSize - unitSize + 2.5\n    );\n    canvasContext.stroke();\n\n    canvasContext.beginPath();\n    canvasContext.lineWidth = 3;\n    canvasContext.fillStyle = \"#000000\";\n    canvasContext.moveTo(unitSize / 4, unitSize / 4);\n    canvasContext.lineTo(3 * (unitSize / 4), unitSize / 2);\n    canvasContext.lineTo(unitSize / 4, 3 * (unitSize / 4));\n    canvasContext.fill();\n\n    canvasContext.beginPath();\n    canvasContext.moveTo(\n      this.width * unitSize - 3 * (unitSize / 4),\n      this.height * unitSize - 3 * (unitSize / 4)\n    );\n    canvasContext.lineTo(\n      this.width * unitSize - unitSize / 4,\n      this.height * unitSize - unitSize / 2\n    );\n    canvasContext.lineTo(\n      this.width * unitSize - 3 * (unitSize / 4),\n      this.height * unitSize - unitSize / 4\n    );\n    canvasContext.fill();\n  };\n}\n","import React, { useRef, useEffect, useState } from \"react\";\nimport {\n  Grid,\n  RecursiveBacktrackMaze,\n} from \"../../../service/mazeGenerator.service\";\nimport { DijkstraSolve } from \"../../../service/mazeSolver.service\";\n\ntype CanvasProps = {\n  maze: Grid | RecursiveBacktrackMaze | DijkstraSolve;\n  delayBetweenFrames: number;\n};\n\nconst Canvas = ({ maze, delayBetweenFrames }: CanvasProps) => {\n  const canvasRef = useRef(null);\n  const [step, setStep] = useState(0);\n  const [measured, setMeasured] = useState(false);\n  const [unitSize, setUnitSize] = useState(1);\n  const [context, setContext] = useState(\n    document.createElement(\"canvas\").getContext(\"2d\")\n  );\n\n  useEffect(() => {\n    setStep(0);\n    const canvas: any = canvasRef.current;\n    const tmpContext = canvas.getContext(\"2d\");\n    const parentDiv = canvas.parentElement;\n    if (!measured) {\n      tmpContext.canvas.width = parentDiv?.offsetWidth;\n      tmpContext.canvas.height = parentDiv?.offsetHeight;\n      let tempUnitSize = 1;\n      while (\n        tempUnitSize * maze.height < tmpContext.canvas.height - 50 &&\n        tempUnitSize * maze.width < tmpContext.canvas.width - 50\n      ) {\n        tempUnitSize += 1;\n      }\n      setUnitSize(tempUnitSize);\n      setMeasured(true);\n      tmpContext.translate(5, 5);\n      setContext(tmpContext);\n    }\n  }, [maze, measured]);\n\n  useEffect(() => {\n    if (!context) throw new Error(\"No context\");\n\n    context.clearRect(\n      0,\n      0,\n      maze.width * unitSize + 300,\n      maze.height * unitSize + 100\n    );\n    context.font = \"20px Roboto\";\n    context.fillText(\n      `${step + 1} / ${maze.frames.length}`,\n      0,\n      maze.height * unitSize + 30\n    );\n    maze.draw(context, unitSize, step);\n\n    setTimeout(() => {\n      if (step + 1 < maze.frames.length) setStep(step + 1);\n    }, delayBetweenFrames);\n  }, [step, context, maze, unitSize, delayBetweenFrames]);\n\n  return <canvas ref={canvasRef} />;\n};\n\nexport default Canvas;\n","import { cloneDeep } from \"lodash\";\nimport { Walls, Cell, Grid, RecursiveDivisionCell } from \"./mazeGenerator.service\";\n// import { cloneDeep } from \"lodash\";\n\nconst getAllCells = (maze: DijkstraSolve): DijkstraCell[] => {\n  let cells: DijkstraCell[] = [];\n  for (let row of maze.grid) {\n    for (let cell of row) {\n      cells.push(cell);\n    }\n  }\n  return cells;\n};\n\nconst getUnvisitedCellFromDirection = (\n  cell: DijkstraCell,\n  direction: string,\n  grid: DijkstraCell[][]\n): DijkstraCell | null => {\n  switch (direction) {\n    case \"N\":\n      if (!grid[cell.x][cell.y - 1]?.visited) return grid[cell.x][cell.y - 1];\n      return null;\n    case \"E\":\n      if (!grid[cell.x + 1][cell.y]?.visited) return grid[cell.x + 1][cell.y];\n      return null;\n    case \"S\":\n      if (!grid[cell.x][cell.y + 1]?.visited) return grid[cell.x][cell.y + 1];\n      return null;\n    case \"W\":\n      if (!grid[cell.x - 1][cell.y]?.visited) return grid[cell.x - 1][cell.y];\n      return null;\n    default:\n      return null;\n  }\n};\n\nconst getUnvisitedNeighbours = (\n  cell: DijkstraCell,\n  grid: DijkstraCell[][]\n): DijkstraCell[] => {\n  let allMoves = [\"N\", \"E\", \"S\", \"W\"];\n  let cellWalls: string[] = [];\n\n  Object.entries(cell.walls).forEach(([key, value]) => {\n    if (value) cellWalls.push(key);\n  });\n\n  const isCell = (candidate: any): candidate is DijkstraCell => {\n    if (candidate instanceof DijkstraCell) return true;\n    return false;\n  };\n\n  const cellMoves = allMoves\n    .filter((n) => !cellWalls.includes(n))\n    .map((move) => getUnvisitedCellFromDirection(cell, move, grid));\n  const unvisitedNeighbours: DijkstraCell[] = cellMoves.filter(isCell);\n\n  return unvisitedNeighbours;\n};\n\nconst sortNodesByDistance = (nodeList: DijkstraCell[]) => {\n  return nodeList.sort(\n    (firstNode, secondNode) =>\n      firstNode.distanceFromSource - secondNode.distanceFromSource\n  );\n};\n\nconst cellNotOnPathFromDirection = (\n  direction: string,\n  cell: DijkstraCell,\n  grid: DijkstraCell[][]\n): DijkstraCell | null => {\n  switch (direction) {\n    case \"N\":\n      if (!grid[cell.x][cell.y - 1]?.onPath) return grid[cell.x][cell.y - 1];\n      return null;\n    case \"E\":\n      if (!grid[cell.x + 1][cell.y]?.onPath) return grid[cell.x + 1][cell.y];\n      return null;\n    case \"S\":\n      if (!grid[cell.x][cell.y + 1]?.onPath) return grid[cell.x][cell.y + 1];\n      return null;\n    case \"W\":\n      if (!grid[cell.x - 1][cell.y]?.onPath) return grid[cell.x - 1][cell.y];\n      return null;\n    default:\n      return null;\n  }\n};\n\nconst getCellWalls = (cell: DijkstraCell) => {\n  let cellWalls: string[] = [];\n\n  Object.entries(cell.walls).forEach(([key, value]) => {\n    if (value) cellWalls.push(key);\n  });\n\n  return cellWalls;\n};\n\nclass CellForSolving extends Cell {\n  visited: boolean;\n  walls: Walls;\n\n  constructor(cell: Cell) {\n    super(cell.x, cell.y);\n    this.visited = false;\n    this.walls = cell.walls;\n  }\n}\n\nclass DijkstraCell extends CellForSolving {\n  distanceFromSource: number;\n  moveCost: number;\n  onPath: boolean;\n\n  constructor(cell: Cell) {\n    super(cell);\n    this.distanceFromSource = Infinity;\n    this.moveCost = 1;\n    this.onPath = false;\n  }\n}\n\nexport class DijkstraSolve extends Grid {\n  grid: DijkstraCell[][];\n  frames: DijkstraCell[][][];\n  mazeCells: Cell[][];\n\n  constructor(maze: Grid, animate: boolean) {\n    super(maze.width, maze.height, animate);\n    this.frames = [];\n    this.algorithm = \"DijkstraSolve\";\n    this.mazeCells = maze.grid;\n    this.grid = this.generateGrid();\n    this.createFrame();\n    try {\n      this.solve();\n    } catch (error) {\n      alert(\"This maze cannot be solved!\");\n      console.log(error);\n    }\n  }\n\n  generateGrid = () => {\n    const dijkstraGrid = this.mazeCells.map(\n      (row: RecursiveDivisionCell[] | Cell[]) => {\n        return row.map((cell: RecursiveDivisionCell | Cell) => {\n          return new DijkstraCell(cell);\n        });\n      }\n    );\n    return dijkstraGrid;\n  };\n\n  getClosestVisitableNeighbour(cell: DijkstraCell) {\n    let allMoves = [\"N\", \"E\", \"S\", \"W\"];\n    const cellWalls = getCellWalls(cell);\n\n    const isDijkstraCell = (candidate: any): candidate is DijkstraCell => {\n      if (candidate instanceof DijkstraCell) return true;\n      return false;\n    };\n\n    const cellMoves = allMoves\n      .filter((n) => !cellWalls.includes(n))\n      .map((move) => cellNotOnPathFromDirection(move, cell, this.grid));\n\n    const validMoves: DijkstraCell[] = cellMoves.filter(isDijkstraCell);\n\n    const closestMove = validMoves.reduce((lowest, cell) =>\n      lowest.distanceFromSource < cell.distanceFromSource ? lowest : cell\n    );\n\n    return closestMove;\n  }\n\n  updateNeighbourDistances = (currentCell: DijkstraCell) => {\n    const updateDistance = (currentCell: DijkstraCell, targetCell: DijkstraCell) => {\n      targetCell.distanceFromSource =\n        currentCell.distanceFromSource + targetCell.moveCost;\n    };\n\n    const neighbours = getUnvisitedNeighbours(currentCell, this.grid);\n\n    neighbours.forEach((cell: DijkstraCell) => {\n      updateDistance(currentCell, cell);\n    });\n  };\n\n  solve = () => {\n    const t0 = performance.now();\n    const exitCell = this.grid[this.width - 1][this.height - 1];\n    const unvisitedCells = getAllCells(this);\n    const startCell = this.grid[0][0];\n    startCell.distanceFromSource = 0;\n\n    while (!!unvisitedCells.length) {\n      sortNodesByDistance(unvisitedCells);\n      const currentCell = unvisitedCells.shift();\n\n      if (currentCell === undefined) break;\n      if (currentCell.distanceFromSource === Infinity) break;\n      if (currentCell === exitCell) break;\n\n      currentCell.visited = true;\n\n      this.updateNeighbourDistances(currentCell);\n      this.createFrame();\n    }\n\n    let currentCell = exitCell;\n\n    while (!(currentCell === startCell)) {\n      currentCell.onPath = true;\n      const nextCell = this.getClosestVisitableNeighbour(currentCell);\n      this.createFrame();\n\n      currentCell = nextCell;\n    }\n\n    startCell.onPath = true;\n    this.frames.push(cloneDeep(this.grid));\n\n    const t1 = performance.now();\n    console.log(\"solved in:\", t1 - t0, \"milliseconds.\");\n  };\n\n  draw(canvasContext: any, unitSize: number, step: number) {\n    if (this.frames[step] === undefined) return;\n\n    canvasContext.strokeStyle = \"#800080\";\n    canvasContext.lineWidth = 5;\n    canvasContext.beginPath();\n    this.frames[step].forEach((row) => {\n      row.forEach((cell) => {\n        if (cell.visited) {\n          canvasContext.fillStyle = \"#FDA4BA\";\n          canvasContext.fillRect(\n            cell.x * unitSize,\n            cell.y * unitSize,\n            unitSize + 1,\n            unitSize + 1\n          );\n        }\n        if (cell.onPath) {\n          canvasContext.fillStyle = \"#00BFFF\";\n          canvasContext.fillRect(\n            cell.x * unitSize,\n            cell.y * unitSize,\n            unitSize,\n            unitSize\n          );\n        }\n\n        canvasContext.moveTo(cell.x * unitSize - 2.5, cell.y * unitSize);\n        if (cell.walls.N) {\n          canvasContext.lineTo(cell.x * unitSize + unitSize, cell.y * unitSize);\n        } else {\n          canvasContext.moveTo(cell.x * unitSize + unitSize, cell.y * unitSize);\n        }\n        if (cell.walls.E) {\n          canvasContext.lineTo(\n            cell.x * unitSize + unitSize,\n            cell.y * unitSize + unitSize\n          );\n        } else {\n          canvasContext.moveTo(\n            cell.x * unitSize + unitSize,\n            cell.y * unitSize + unitSize\n          );\n        }\n        if (cell.walls.S) {\n          canvasContext.lineTo(cell.x * unitSize, cell.y * unitSize + unitSize);\n        } else {\n          canvasContext.moveTo(cell.x * unitSize, cell.y * unitSize + unitSize);\n        }\n        if (cell.walls.W) {\n          canvasContext.lineTo(cell.x * unitSize, cell.y * unitSize);\n        } else {\n          canvasContext.moveTo(cell.x * unitSize, cell.y * unitSize);\n        }\n      });\n    });\n    canvasContext.stroke();\n\n    canvasContext.beginPath();\n    canvasContext.lineJoin = \"round\";\n    canvasContext.lineWidth = 10;\n    canvasContext.rect(0, 0, this.width * unitSize, this.height * unitSize);\n    canvasContext.stroke();\n\n    canvasContext.beginPath();\n    canvasContext.lineWidth = 10;\n    canvasContext.strokeStyle = \"#FFFFFF\";\n    canvasContext.moveTo(0, 5);\n    canvasContext.lineTo(0, unitSize - 2.5);\n    canvasContext.moveTo(this.width * unitSize, this.height * unitSize - 5);\n    canvasContext.lineTo(\n      this.width * unitSize,\n      this.height * unitSize - unitSize + 2.5\n    );\n    canvasContext.stroke();\n\n    canvasContext.beginPath();\n    canvasContext.lineWidth = 3;\n    canvasContext.fillStyle = \"#000000\";\n    canvasContext.moveTo(unitSize / 4, unitSize / 4);\n    canvasContext.lineTo(3 * (unitSize / 4), unitSize / 2);\n    canvasContext.lineTo(unitSize / 4, 3 * (unitSize / 4));\n    canvasContext.fill();\n\n    canvasContext.beginPath();\n    canvasContext.moveTo(\n      this.width * unitSize - 3 * (unitSize / 4),\n      this.height * unitSize - 3 * (unitSize / 4)\n    );\n    canvasContext.lineTo(\n      this.width * unitSize - unitSize / 4,\n      this.height * unitSize - unitSize / 2\n    );\n    canvasContext.lineTo(\n      this.width * unitSize - 3 * (unitSize / 4),\n      this.height * unitSize - unitSize / 4\n    );\n    canvasContext.fill();\n  }\n}\n","import Maze from \"./Maze\";\n\nexport default Maze","import React, { useState, useRef } from \"react\";\nimport styles from \"./Maze.module.scss\";\nimport {\n  Grid,\n  RecursiveBacktrackMaze,\n  RecursiveDivisionMaze,\n} from \"../../service/mazeGenerator.service\";\nimport Canvas from \"./Canvas/Canvas\";\nimport { cloneDeep } from \"lodash\";\nimport { DijkstraSolve } from \"../../service/mazeSolver.service\";\n\nconst Maze = () => {\n  const [dimensions] = useState({ width: 30, height: 15 });\n  const [maze, setMaze] = useState(new Grid(dimensions.width, dimensions.height));\n  const [delayBetweenFrames, setFrameDelay] = useState(1);\n  const [animate, setAnimate] = useState(true);\n\n  let solveButtonRef = useRef<HTMLButtonElement>(null);\n  let backtrackButtonRef = useRef<HTMLButtonElement>(null);\n  let divisionButtonRef = useRef<HTMLButtonElement>(null);\n\n  const handleChange = (event: any): void => {\n    let newDelay = Number(event.target.value);\n    newDelay = Math.max(newDelay, 0);\n    newDelay = Math.min(newDelay, 2000);\n    setFrameDelay(newDelay);\n  };\n\n  const handleSolveClick = () => {\n    if (!!solveButtonRef.current)\n      solveButtonRef.current.setAttribute(\"disabled\", \"disabled\");\n    setMaze(new DijkstraSolve(maze, animate));\n    if (!!solveButtonRef.current) solveButtonRef.current.removeAttribute(\"disabled\");\n  };\n\n  const handleBacktrackClick = () => {\n    if (!!backtrackButtonRef.current)\n      backtrackButtonRef.current.setAttribute(\"disabled\", \"disabled\");\n    setMaze(\n      new RecursiveBacktrackMaze(dimensions.width, dimensions.height, animate)\n    );\n    if (!!backtrackButtonRef.current)\n      backtrackButtonRef.current.removeAttribute(\"disabled\");\n  };\n\n  const handleDivisionClick = () => {\n    if (!!divisionButtonRef.current)\n      divisionButtonRef.current.setAttribute(\"disabled\", \"disabled\");\n    setMaze(new RecursiveDivisionMaze(dimensions.width, dimensions.height, animate));\n    if (!!divisionButtonRef.current)\n      divisionButtonRef.current.removeAttribute(\"disabled\");\n  };\n\n  return (\n    <div className={styles.mazeContainer}>\n      <div className={styles.maze} id=\"maze\">\n        <Canvas maze={maze} delayBetweenFrames={delayBetweenFrames} />\n        <div>\n          <button\n            onClick={() => {\n              setMaze(cloneDeep(maze));\n            }}\n          >\n            Re-run\n          </button>\n          <button ref={backtrackButtonRef} onClick={handleBacktrackClick}>\n            New Backtrack maze\n          </button>\n          <button ref={divisionButtonRef} onClick={handleDivisionClick}>\n            New Division maze\n          </button>\n          <button ref={solveButtonRef} onClick={handleSolveClick}>\n            Solve\n          </button>\n          Interval:{\" \"}\n          <input\n            type=\"number\"\n            min=\"1\"\n            max=\"1000\"\n            step=\"10\"\n            defaultValue={delayBetweenFrames}\n            onChange={handleChange}\n          />{\" \"}\n          ms.\n          <input\n            type=\"checkbox\"\n            name=\"animate\"\n            id=\"animate\"\n            defaultChecked={true}\n            onChange={() => {\n              setAnimate(!animate);\n            }}\n          />\n          Animate\n        </div>\n      </div>\n    </div>\n  );\n};\n\nexport default Maze;\n","import React from 'react';\nimport './App.css';\nimport SelectionBar from './components/SelectionBar';\nimport Maze from './components/Maze';\n\nfunction App() {\n  return (\n    <div className='App'>\n    <SelectionBar />\n    <Maze />\n    </div>\n  );\n}\n\nexport default App;\n","import { ReportHandler } from 'web-vitals';\n\nconst reportWebVitals = (onPerfEntry?: ReportHandler) => {\n  if (onPerfEntry && onPerfEntry instanceof Function) {\n    import('web-vitals').then(({ getCLS, getFID, getFCP, getLCP, getTTFB }) => {\n      getCLS(onPerfEntry);\n      getFID(onPerfEntry);\n      getFCP(onPerfEntry);\n      getLCP(onPerfEntry);\n      getTTFB(onPerfEntry);\n    });\n  }\n};\n\nexport default reportWebVitals;\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport reportWebVitals from './reportWebVitals';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n// If you want to start measuring performance in your app, pass a function\n// to log results (for example: reportWebVitals(console.log))\n// or send to an analytics endpoint. Learn more: https://bit.ly/CRA-vitals\nreportWebVitals();\n"],"sourceRoot":""}