{"version":3,"sources":["components/Maze/Maze.module.scss","components/SelectionBar/SelectionBar.module.scss","components/SelectionBar/index.ts","components/SelectionBar/SelectionBar.tsx","service/mazeGenerator.service.ts","components/Maze/Canvas/Canvas.tsx","service/mazeSolver.service.ts","components/Maze/index.ts","components/Maze/Maze.tsx","App.tsx","reportWebVitals.ts","index.tsx"],"names":["module","exports","SelectionBar","className","styles","selectionBar","Walls","N","E","S","W","this","EmptyWalls","Cell","x","y","walls","visited","backtracked","RecursiveDivisionCell","currentArea","getOppositeDirection","direction","Grid","width","height","grid","stack","frames","algorithm","possibleMoves","cell","moves","push","col","cloneDeep","canvasContext","unitSize","step","beginPath","forEach","strokeStyle","lineWidth","fillStyle","fillRect","moveTo","lineTo","stroke","lineJoin","rect","fill","RecursiveBacktrackMaze","generateMaze","currentFrame","directions","Math","floor","random","length","newCell","newCellFromDirection","newDirection","oldCell","pop","t0","performance","now","lastFrame","t1","console","log","RecursiveDivisionMaze","setIndividualWall","addWalls","neighbour","getRandomIntBetween","min","max","ceil","recursiveGenerate","verticalSpace","index","column","map","randomCell","setHorizontalWall","half1","half2","slice","setVerticalWall","draw","Canvas","maze","delayBetweenFrames","canvasRef","useRef","useState","setStep","measured","setMeasured","setUnitSize","document","createElement","getContext","context","setContext","useEffect","canvas","current","tmpContext","parentDiv","parentElement","offsetWidth","offsetHeight","tempUnitSize","translate","Error","clearRect","font","fillText","setTimeout","ref","DijkstraCell","distanceFromSource","moveCost","onPath","Infinity","distance","DijkstraMaze","getUnvisitedNeighbours","cellWalls","Object","entries","key","filter","n","includes","move","cellFromDirection","candidate","getAllNodes","nodes","row","updateNeighbourDistances","currentCell","targetCell","updateDistance","solve","exitCell","unvisitedCells","startCell","sort","firstNode","secondNode","shift","undefined","nextCell","getBestPathNeighbor","reduce","lowest","Maze","dimensions","setMaze","setFrameDelay","mazeContainer","id","onClick","type","defaultValue","onChange","event","newDelay","Number","target","value","App","reportWebVitals","onPerfEntry","Function","then","getCLS","getFID","getFCP","getLCP","getTTFB","ReactDOM","render","StrictMode","getElementById"],"mappings":"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","file":"static/js/main.78d00526.chunk.js","sourcesContent":["// extracted by mini-css-extract-plugin\nmodule.exports = {\"mazeContainer\":\"Maze_mazeContainer__3Exuk\",\"maze\":\"Maze_maze__2NaIp\"};","// extracted by mini-css-extract-plugin\nmodule.exports = {\"selectionBar\":\"SelectionBar_selectionBar__14QJ9\"};","import SelectionBar from \"./SelectionBar\";\n\nexport default SelectionBar","import React from 'react'\nimport styles from './SelectionBar.module.scss'\n\nconst SelectionBar = () => {\n    return (\n        <div className={styles.selectionBar}>\n            <h1>Maze Generator</h1>\n        </div>\n    )\n}\n\nexport default SelectionBar\n","import { cloneDeep } from \"lodash\";\n\nexport class Walls {\n  N: boolean;\n  E: boolean;\n  S: boolean;\n  W: boolean;\n  [key: string]: boolean;\n\n  constructor() {\n    this.N = true;\n    this.E = true;\n    this.S = true;\n    this.W = true;\n  }\n}\n\nexport class EmptyWalls extends Walls {\n  constructor() {\n    super();\n    this.N = false;\n    this.E = false;\n    this.S = false;\n    this.W = false;\n  }\n}\n\nexport class Cell {\n  x: number;\n  y: number;\n  walls: Walls;\n  visited: boolean;\n  backtracked: boolean;\n\n  constructor(x: number, y: number) {\n    this.x = x;\n    this.y = y;\n    this.walls = new Walls();\n    this.visited = false;\n    this.backtracked = false;\n  }\n}\n\nexport class RecursiveDivisionCell extends Cell {\n  currentArea: boolean;\n\n  constructor(x: number, y: number) {\n    super(x, y);\n    this.walls = new EmptyWalls();\n    this.currentArea = true;\n  }\n}\n\nconst getOppositeDirection = (direction: string): string | null => {\n  switch (direction) {\n    case \"N\":\n      return \"S\";\n    case \"E\":\n      return \"W\";\n    case \"S\":\n      return \"N\";\n    case \"W\":\n      return \"E\";\n    default:\n      return null;\n  }\n};\n\nexport class Grid {\n  height: number;\n  width: number;\n  grid: Cell[][];\n  stack: Cell[];\n  frames: Cell[][][];\n  algorithm: string;\n  [key: string]: any;\n\n  constructor(width: number, height: number) {\n    this.height = height <= 50 ? height : 50;\n    this.width = width <= 50 ? width : 50;\n    this.grid = [];\n    this.stack = [];\n    this.algorithm = \"grid\";\n\n    for (let x = 0; x < width; x++) {\n      let col = [];\n      for (let y = 0; y < height; y++) {\n        col.push(new Cell(x, y));\n      }\n      this.grid.push(col);\n    }\n\n    this.frames = cloneDeep([this.grid]);\n    this.grid[0][0].visited = true;\n  }\n\n  possibleMoves = (cell: Cell): string[] => {\n    let moves = [];\n    if (cell.y - 1 >= 0 && !this.grid[cell.x][cell.y - 1].visited) moves.push(\"N\");\n    if (cell.x + 1 < this.width && !this.grid[cell.x + 1][cell.y].visited)\n      moves.push(\"E\");\n    if (cell.y + 1 < this.height && !this.grid[cell.x][cell.y + 1].visited)\n      moves.push(\"S\");\n    if (cell.x - 1 >= 0 && !this.grid[cell.x - 1][cell.y].visited) moves.push(\"W\");\n    return moves;\n  };\n\n  generateMaze(cell: Cell) {}\n\n  draw(canvasContext: any, unitSize: number, step: number) {\n    // canvasContext.clearRect(0, 0, unitSize * this.width, unitSize * this.height);\n    canvasContext.beginPath();\n    this.frames[step].forEach((col) => {\n      canvasContext.strokeStyle = \"#800080\";\n      canvasContext.lineWidth = 5;\n      col.forEach((cell) => {\n        canvasContext.fillStyle = \"#FDA4BA\";\n        if (cell.visited && !cell.backtracked) {\n          canvasContext.fillRect(\n            cell.x * unitSize,\n            cell.y * unitSize,\n            unitSize + 1,\n            unitSize + 1\n          );\n        }\n        canvasContext.moveTo(cell.x * unitSize - 2.5, cell.y * unitSize);\n        if (cell.walls.N) {\n          canvasContext.lineTo(cell.x * unitSize + unitSize, cell.y * unitSize);\n        } else {\n          canvasContext.moveTo(cell.x * unitSize + unitSize, cell.y * unitSize);\n        }\n        if (cell.walls.E) {\n          canvasContext.lineTo(\n            cell.x * unitSize + unitSize,\n            cell.y * unitSize + unitSize\n          );\n        } else {\n          canvasContext.moveTo(\n            cell.x * unitSize + unitSize,\n            cell.y * unitSize + unitSize\n          );\n        }\n        if (cell.walls.S) {\n          canvasContext.lineTo(cell.x * unitSize, cell.y * unitSize + unitSize);\n        } else {\n          canvasContext.moveTo(cell.x * unitSize, cell.y * unitSize + unitSize);\n        }\n        if (cell.walls.W) {\n          canvasContext.lineTo(cell.x * unitSize, cell.y * unitSize);\n        } else {\n          canvasContext.moveTo(cell.x * unitSize, cell.y * unitSize);\n        }\n      });\n    });\n    canvasContext.stroke();\n\n    canvasContext.beginPath();\n    canvasContext.lineJoin = \"round\";\n    canvasContext.lineWidth = 10;\n    canvasContext.rect(0, 0, this.width * unitSize, this.height * unitSize);\n    canvasContext.stroke();\n\n    canvasContext.beginPath();\n    canvasContext.lineWidth = 10;\n    canvasContext.strokeStyle = \"#FFFFFF\";\n    canvasContext.moveTo(0, 5);\n    canvasContext.lineTo(0, unitSize - 2.5);\n    canvasContext.moveTo(this.width * unitSize, this.height * unitSize - 5);\n    canvasContext.lineTo(\n      this.width * unitSize,\n      this.height * unitSize - unitSize + 2.5\n    );\n    canvasContext.stroke();\n\n    canvasContext.beginPath();\n    canvasContext.lineWidth = 3;\n    canvasContext.fillStyle = \"#000000\";\n    canvasContext.moveTo(unitSize / 4, unitSize / 4);\n    canvasContext.lineTo(3 * (unitSize / 4), unitSize / 2);\n    canvasContext.lineTo(unitSize / 4, 3 * (unitSize / 4));\n    canvasContext.fill();\n\n    canvasContext.beginPath();\n    canvasContext.moveTo(\n      this.width * unitSize - 3 * (unitSize / 4),\n      this.height * unitSize - 3 * (unitSize / 4)\n    );\n    canvasContext.lineTo(\n      this.width * unitSize - unitSize / 4,\n      this.height * unitSize - unitSize / 2\n    );\n    canvasContext.lineTo(\n      this.width * unitSize - 3 * (unitSize / 4),\n      this.height * unitSize - unitSize / 4\n    );\n    canvasContext.fill();\n  }\n}\n\nexport class RecursiveBacktrackMaze extends Grid {\n  constructor(width: number, height: number) {\n    super(width, height);\n    const t0 = performance.now();\n    this.algorithm = \"recursiveBacktrackGenerate\";\n    this.generateMaze(this.grid[0][0]);\n\n    let lastFrame = this.frames.pop();\n    if (lastFrame) {\n      lastFrame[0][0].backtracked = true;\n      this.frames.push(cloneDeep(lastFrame));\n    }\n    const t1 = performance.now();\n    console.log(\"maze generated in: \", t1 - t0, \" milliseconds.\");\n  }\n\n  generateMaze = (cell: Cell) => {\n    const currentFrame = cloneDeep(this.grid);\n    this.frames.push(currentFrame);\n\n    const newCellFromDirection = (direction: string): Cell | null => {\n      switch (direction) {\n        case \"N\":\n          return this.grid[cell.x][cell.y - 1];\n        case \"E\":\n          return this.grid[cell.x + 1][cell.y];\n        case \"S\":\n          return this.grid[cell.x][cell.y + 1];\n        case \"W\":\n          return this.grid[cell.x - 1][cell.y];\n        default:\n          return null;\n      }\n    };\n\n    const directions = this.possibleMoves(cell);\n    const direction = directions[Math.floor(Math.random() * directions.length)];\n    const newCell = newCellFromDirection(direction);\n    const newDirection = getOppositeDirection(direction);\n\n    if (!newCell && !(this.stack.length > 0)) return;\n\n    if (newCell && newDirection) {\n      this.stack.push(cell);\n      cell.walls[direction] = false;\n      newCell.walls[newDirection] = false;\n      newCell.visited = true;\n      this.generateMaze(newCell);\n    } else {\n      cell.backtracked = true;\n      const oldCell = this.stack.pop();\n      if (oldCell) {\n        this.generateMaze(oldCell);\n      }\n    }\n  };\n\n  draw(canvasContext: any, unitSize: number, step: number) {\n    // canvasContext.clearRect(0, 0, unitSize * this.width, unitSize * this.height);\n    canvasContext.beginPath();\n    this.frames[step].forEach((col) => {\n      canvasContext.strokeStyle = \"#800080\";\n      canvasContext.lineWidth = 5;\n      col.forEach((cell) => {\n        canvasContext.fillStyle = \"#FDA4BA\";\n        if (cell.visited && !cell.backtracked) {\n          canvasContext.fillRect(\n            cell.x * unitSize,\n            cell.y * unitSize,\n            unitSize + 1,\n            unitSize + 1\n          );\n        }\n        canvasContext.moveTo(cell.x * unitSize - 2.5, cell.y * unitSize);\n        if (cell.walls.N) {\n          canvasContext.lineTo(cell.x * unitSize + unitSize, cell.y * unitSize);\n        } else {\n          canvasContext.moveTo(cell.x * unitSize + unitSize, cell.y * unitSize);\n        }\n        if (cell.walls.E) {\n          canvasContext.lineTo(\n            cell.x * unitSize + unitSize,\n            cell.y * unitSize + unitSize\n          );\n        } else {\n          canvasContext.moveTo(\n            cell.x * unitSize + unitSize,\n            cell.y * unitSize + unitSize\n          );\n        }\n        if (cell.walls.S) {\n          canvasContext.lineTo(cell.x * unitSize, cell.y * unitSize + unitSize);\n        } else {\n          canvasContext.moveTo(cell.x * unitSize, cell.y * unitSize + unitSize);\n        }\n        if (cell.walls.W) {\n          canvasContext.lineTo(cell.x * unitSize, cell.y * unitSize);\n        } else {\n          canvasContext.moveTo(cell.x * unitSize, cell.y * unitSize);\n        }\n      });\n    });\n    canvasContext.stroke();\n\n    canvasContext.beginPath();\n    canvasContext.lineJoin = \"round\";\n    canvasContext.lineWidth = 10;\n    canvasContext.rect(0, 0, this.width * unitSize, this.height * unitSize);\n    canvasContext.stroke();\n\n    canvasContext.beginPath();\n    canvasContext.lineWidth = 10;\n    canvasContext.strokeStyle = \"#FFFFFF\";\n    canvasContext.moveTo(0, 5);\n    canvasContext.lineTo(0, unitSize - 2.5);\n    canvasContext.moveTo(this.width * unitSize, this.height * unitSize - 5);\n    canvasContext.lineTo(\n      this.width * unitSize,\n      this.height * unitSize - unitSize + 2.5\n    );\n    canvasContext.stroke();\n\n    canvasContext.beginPath();\n    canvasContext.lineWidth = 3;\n    canvasContext.fillStyle = \"#000000\";\n    canvasContext.moveTo(unitSize / 4, unitSize / 4);\n    canvasContext.lineTo(3 * (unitSize / 4), unitSize / 2);\n    canvasContext.lineTo(unitSize / 4, 3 * (unitSize / 4));\n    canvasContext.fill();\n\n    canvasContext.beginPath();\n    canvasContext.moveTo(\n      this.width * unitSize - 3 * (unitSize / 4),\n      this.height * unitSize - 3 * (unitSize / 4)\n    );\n    canvasContext.lineTo(\n      this.width * unitSize - unitSize / 4,\n      this.height * unitSize - unitSize / 2\n    );\n    canvasContext.lineTo(\n      this.width * unitSize - 3 * (unitSize / 4),\n      this.height * unitSize - unitSize / 4\n    );\n    canvasContext.fill();\n  }\n}\n\nexport class RecursiveDivisionMaze extends Grid {\n  grid: RecursiveDivisionCell[][];\n  frames: RecursiveDivisionCell[][][];\n\n  constructor(width: number, height: number) {\n    super(width, height);\n    const t0 = performance.now();\n    this.algorithm = \"recursiveDivisionGenerate\";\n    this.grid = [];\n    for (let x = 0; x < width; x++) {\n      let col = [];\n      for (let y = 0; y < height; y++) {\n        col.push(new RecursiveDivisionCell(x, y));\n      }\n      this.grid.push(col);\n    }\n\n    //add perimeter walls\n    this.grid[0].forEach((cell) => (cell.walls.W = true));\n    this.grid[this.grid.length - 1].forEach((cell) => (cell.walls.E = true));\n    this.grid.forEach((col) => {\n      col[0].walls.N = true;\n      col[col.length - 1].walls.S = true;\n    });\n\n    this.frames = [this.grid];\n\n    this.generateMaze();\n    const t1 = performance.now();\n    console.log(\"maze generated in: \", t1 - t0, \" milliseconds.\");\n  }\n\n  generateMaze = (): void => {\n    const newCellFromDirection = (\n      cell: RecursiveDivisionCell,\n      direction: string\n    ): RecursiveDivisionCell | undefined => {\n      switch (direction) {\n        case \"N\":\n          return this.grid[cell.x][cell.y - 1];\n        case \"E\":\n          return this.grid[cell.x + 1][cell.y];\n        case \"S\":\n          return this.grid[cell.x][cell.y + 1];\n        case \"W\":\n          return this.grid[cell.x - 1][cell.y];\n        default:\n          return undefined;\n      }\n    };\n\n    const setIndividualWall = (\n      cell: RecursiveDivisionCell,\n      direction: string,\n      addWalls: boolean = true\n    ) => {\n      cell.walls[direction] = addWalls;\n      const neighbour = newCellFromDirection(cell, direction);\n      if (neighbour) neighbour.walls[getOppositeDirection(direction)!] = addWalls;\n    };\n\n    const getRandomIntBetween = (min: number, max: number): number => {\n      min = Math.ceil(min);\n      max = Math.floor(max);\n      return Math.floor(Math.random() * (max - min + 1) + min);\n    };\n\n    const setVerticalWall = (\n      index: number,\n      grid: RecursiveDivisionCell[][]\n    ): void => {\n      const column = grid[index];\n      column.forEach((cell) => {\n        setIndividualWall(cell, \"E\", true);\n      });\n\n      const randomCell = column[getRandomIntBetween(1, column.length - 2)];\n      setIndividualWall(randomCell, \"E\", false);\n      this.frames.push(cloneDeep(this.grid));\n    };\n\n    const setHorizontalWall = (\n      index: number,\n      grid: RecursiveDivisionCell[][]\n    ): void => {\n      const column = grid.map((col) => col[index]);\n      column.forEach((cell) => {\n        setIndividualWall(cell, \"S\", true);\n      });\n\n      const randomCell = column[getRandomIntBetween(1, column.length - 2)];\n      setIndividualWall(randomCell, \"S\", false);\n      this.frames.push(cloneDeep(this.grid));\n    };\n\n    const recursiveGenerate = (grid: RecursiveDivisionCell[][]) => {\n      let width: number;\n      let height: number;\n      let verticalSpace: boolean;\n\n      width = grid.length;\n      height = grid[0].length;\n      verticalSpace = width < height;\n\n      if (width <= 1 || height <= 1) return;\n      this.grid.forEach((col) => col.forEach((cell) => (cell.currentArea = false)));\n      grid.forEach((col) => col.forEach((cell) => (cell.currentArea = true)));\n\n      this.frames.push(cloneDeep(this.grid));\n\n      if (verticalSpace) {\n        const index = getRandomIntBetween(0, height - 1);\n\n        setHorizontalWall(index, grid);\n\n        //split and recurse\n        let half1: RecursiveDivisionCell[][] = [];\n        let half2: RecursiveDivisionCell[][] = [];\n\n        grid.forEach((col) => {\n          half1.push(col.slice(0, index + 1));\n          half2.push(col.slice(index + 1));\n        });\n\n        if (!!half1[0].length) recursiveGenerate(half1);\n        if (!!half2[0].length) recursiveGenerate(half2);\n      } else {\n        const index = getRandomIntBetween(0, width - 2);\n\n        setVerticalWall(index, grid);\n\n        const half1 = grid.slice(0, index + 1);\n        const half2 = grid.slice(index + 1);\n\n        if (!!half1.length) recursiveGenerate(half1);\n        if (!!half2.length) recursiveGenerate(half2);\n      }\n    };\n    this.frames = [this.grid];\n    recursiveGenerate(this.grid);\n    this.grid.forEach((col) => col.forEach((cell) => (cell.currentArea = false)));\n    this.frames.push(cloneDeep(this.grid));\n    console.log(\"generated\");\n  };\n\n  draw = (canvasContext: any, unitSize: number, step: number) => {\n    // canvasContext.clearRect(0, 0, unitSize * this.width, unitSize * this.height);\n    canvasContext.beginPath();\n\n    if (!this.frames[step]) return;\n\n    this.frames[step].forEach((col) => {\n      canvasContext.strokeStyle = \"#800080\";\n      canvasContext.lineWidth = 5;\n      col.forEach((cell) => {\n        canvasContext.fillStyle = \"#FDA4BA\";\n        if (cell.currentArea) {\n          canvasContext.fillRect(\n            cell.x * unitSize,\n            cell.y * unitSize,\n            unitSize + 1,\n            unitSize + 1\n          );\n        }\n        canvasContext.moveTo(cell.x * unitSize - 2.5, cell.y * unitSize);\n        if (cell.walls.N) {\n          canvasContext.lineTo(cell.x * unitSize + unitSize, cell.y * unitSize);\n        } else {\n          canvasContext.moveTo(cell.x * unitSize + unitSize, cell.y * unitSize);\n        }\n        if (cell.walls.E) {\n          canvasContext.lineTo(\n            cell.x * unitSize + unitSize,\n            cell.y * unitSize + unitSize\n          );\n        } else {\n          canvasContext.moveTo(\n            cell.x * unitSize + unitSize,\n            cell.y * unitSize + unitSize\n          );\n        }\n        if (cell.walls.S) {\n          canvasContext.lineTo(cell.x * unitSize, cell.y * unitSize + unitSize);\n        } else {\n          canvasContext.moveTo(cell.x * unitSize, cell.y * unitSize + unitSize);\n        }\n        if (cell.walls.W) {\n          canvasContext.lineTo(cell.x * unitSize, cell.y * unitSize);\n        } else {\n          canvasContext.moveTo(cell.x * unitSize, cell.y * unitSize);\n        }\n      });\n    });\n    canvasContext.stroke();\n\n    canvasContext.beginPath();\n    canvasContext.lineJoin = \"round\";\n    canvasContext.lineWidth = 10;\n    canvasContext.rect(0, 0, this.width * unitSize, this.height * unitSize);\n    canvasContext.stroke();\n\n    canvasContext.beginPath();\n    canvasContext.lineWidth = 10;\n    canvasContext.strokeStyle = \"#FFFFFF\";\n    canvasContext.moveTo(0, 5);\n    canvasContext.lineTo(0, unitSize - 2.5);\n    canvasContext.moveTo(this.width * unitSize, this.height * unitSize - 5);\n    canvasContext.lineTo(\n      this.width * unitSize,\n      this.height * unitSize - unitSize + 2.5\n    );\n    canvasContext.stroke();\n\n    canvasContext.beginPath();\n    canvasContext.lineWidth = 3;\n    canvasContext.fillStyle = \"#000000\";\n    canvasContext.moveTo(unitSize / 4, unitSize / 4);\n    canvasContext.lineTo(3 * (unitSize / 4), unitSize / 2);\n    canvasContext.lineTo(unitSize / 4, 3 * (unitSize / 4));\n    canvasContext.fill();\n\n    canvasContext.beginPath();\n    canvasContext.moveTo(\n      this.width * unitSize - 3 * (unitSize / 4),\n      this.height * unitSize - 3 * (unitSize / 4)\n    );\n    canvasContext.lineTo(\n      this.width * unitSize - unitSize / 4,\n      this.height * unitSize - unitSize / 2\n    );\n    canvasContext.lineTo(\n      this.width * unitSize - 3 * (unitSize / 4),\n      this.height * unitSize - unitSize / 4\n    );\n    canvasContext.fill();\n  };\n}\n","import React, { useRef, useEffect, useState } from \"react\";\nimport {\n  Grid,\n  RecursiveBacktrackMaze,\n  RecursiveDivisionMaze,\n} from \"../../../service/mazeGenerator.service\";\nimport { DijkstraMaze } from \"../../../service/mazeSolver.service\";\n\ntype CanvasProps = {\n  maze: Grid | RecursiveBacktrackMaze | RecursiveDivisionMaze | DijkstraMaze;\n  delayBetweenFrames: number;\n};\n\nconst Canvas = ({ maze, delayBetweenFrames }: CanvasProps) => {\n  const canvasRef = useRef(null);\n  const [step, setStep] = useState(0);\n  const [measured, setMeasured] = useState(false);\n  const [unitSize, setUnitSize] = useState(1);\n  const [context, setContext] = useState(\n    document.createElement(\"canvas\").getContext(\"2d\")\n  );\n\n  useEffect(() => {\n    setStep(0);\n    const canvas: any = canvasRef.current;\n    const tmpContext = canvas.getContext(\"2d\");\n    const parentDiv = canvas.parentElement;\n    if (!measured) {\n      tmpContext.canvas.width = parentDiv?.offsetWidth;\n      tmpContext.canvas.height = parentDiv?.offsetHeight;\n      let tempUnitSize = 1;\n      while (\n        tempUnitSize * maze.height < tmpContext.canvas.height - 50 &&\n        tempUnitSize * maze.width < tmpContext.canvas.width - 50\n      ) {\n        tempUnitSize += 1;\n      }\n      setUnitSize(tempUnitSize);\n      setMeasured(true);\n      tmpContext.translate(5, 5);\n      setContext(tmpContext);\n    }\n  }, [maze, measured]);\n\n  useEffect(() => {\n    if (!context) throw new Error(\"No context\");\n\n    context.clearRect(\n      0,\n      0,\n      maze.width * unitSize + 300,\n      maze.height * unitSize + 100\n    );\n    context.font = \"20px Roboto\";\n    context.fillText(\n      `${step + 1} / ${maze.frames.length}`,\n      0,\n      maze.height * unitSize + 30\n    );\n    maze.draw(context, unitSize, step);\n\n    setTimeout(() => {\n      if (step + 1 < maze.frames.length) setStep(step + 1);\n    }, delayBetweenFrames);\n  }, [step, context, maze, unitSize, delayBetweenFrames]);\n\n  return <canvas ref={canvasRef} />;\n};\n\nexport default Canvas;\n","import {\n  RecursiveBacktrackMaze,\n  Walls,\n  Cell,\n  Grid,\n  RecursiveDivisionMaze,\n  RecursiveDivisionCell,\n} from \"./mazeGenerator.service\";\nimport { cloneDeep } from \"lodash\";\n\nclass CellForSolving extends Cell {\n  visited: boolean;\n  walls: Walls;\n\n  constructor(cell: Cell) {\n    super(cell.x, cell.y);\n    this.visited = false;\n    this.walls = cell.walls;\n  }\n}\n\nclass DijkstraCell extends CellForSolving {\n  distanceFromSource: number;\n  moveCost: number;\n  onPath: boolean;\n\n  constructor(cell: Cell) {\n    super(cell);\n    this.distanceFromSource = Infinity;\n    this.moveCost = 1;\n    this.onPath = false;\n  }\n\n  setDistanceFromSource(distance: number) {\n    this.distanceFromSource = distance;\n  }\n}\n\nexport class DijkstraMaze extends Grid {\n  grid: DijkstraCell[][];\n  frames: DijkstraCell[][][];\n\n  constructor(maze: RecursiveBacktrackMaze | RecursiveDivisionMaze) {\n    super(maze.width, maze.height);\n    this.frames = [];\n    this.algorithm = \"DijkstraSolve\";\n\n    this.grid = maze.grid.map((row: RecursiveDivisionCell[] | Cell[]) => {\n      return row.map((cell: RecursiveDivisionCell | Cell) => {\n        return new DijkstraCell(cell);\n      });\n    });\n\n    this.solve();\n  }\n\n  getUnvisitedNeighbours = (cell: DijkstraCell): DijkstraCell[] => {\n    let allMoves = [\"N\", \"E\", \"S\", \"W\"];\n    let cellWalls: string[] = [];\n\n    Object.entries(cell.walls).forEach(([key, value]) => {\n      if (value) cellWalls.push(key);\n    });\n\n    const cellFromDirection = (direction: string): DijkstraCell | null => {\n      switch (direction) {\n        case \"N\":\n          if (!this.grid[cell.x][cell.y - 1]?.visited)\n            return this.grid[cell.x][cell.y - 1];\n          return null;\n        case \"E\":\n          if (!this.grid[cell.x + 1][cell.y]?.visited)\n            return this.grid[cell.x + 1][cell.y];\n          return null;\n        case \"S\":\n          if (!this.grid[cell.x][cell.y + 1]?.visited)\n            return this.grid[cell.x][cell.y + 1];\n          return null;\n        case \"W\":\n          if (!this.grid[cell.x - 1][cell.y]?.visited)\n            return this.grid[cell.x - 1][cell.y];\n          return null;\n        default:\n          return null;\n      }\n    };\n\n    const isCell = (candidate: any): candidate is DijkstraCell => {\n      if (candidate instanceof DijkstraCell) return true;\n      return false;\n    };\n\n    const cellMoves = allMoves\n      .filter((n) => !cellWalls.includes(n))\n      .map((move) => cellFromDirection(move));\n    const validMoves: DijkstraCell[] = cellMoves.filter(isCell)!;\n\n    return validMoves;\n  };\n\n  getBestPathNeighbor(cell: DijkstraCell) {\n    let allMoves = [\"N\", \"E\", \"S\", \"W\"];\n    let cellWalls: string[] = [];\n\n    Object.entries(cell.walls).forEach(([key, value]) => {\n      if (value) cellWalls.push(key);\n    });\n\n    const cellFromDirection = (direction: string): DijkstraCell | null => {\n      switch (direction) {\n        case \"N\":\n          if (!this.grid[cell.x][cell.y - 1]?.onPath)\n            return this.grid[cell.x][cell.y - 1];\n          return null;\n        case \"E\":\n          if (!this.grid[cell.x + 1][cell.y]?.onPath)\n            return this.grid[cell.x + 1][cell.y];\n          return null;\n        case \"S\":\n          if (!this.grid[cell.x][cell.y + 1]?.onPath)\n            return this.grid[cell.x][cell.y + 1];\n          return null;\n        case \"W\":\n          if (!this.grid[cell.x - 1][cell.y]?.onPath)\n            return this.grid[cell.x - 1][cell.y];\n          return null;\n        default:\n          return null;\n      }\n    };\n\n    const isCell = (candidate: any): candidate is DijkstraCell => {\n      if (candidate instanceof DijkstraCell) return true;\n      return false;\n    };\n\n    const cellMoves = allMoves\n      .filter((n) => !cellWalls.includes(n))\n      .map((move) => cellFromDirection(move));\n    const validMoves: DijkstraCell[] = cellMoves.filter(isCell)!;\n\n    return validMoves.reduce((lowest, cell) =>\n      lowest.distanceFromSource < cell.distanceFromSource ? lowest : cell\n    );\n  }\n\n  getAllNodes = (): DijkstraCell[] => {\n    let nodes: DijkstraCell[] = [];\n    for (let row of this.grid) {\n      for (let cell of row) {\n        nodes.push(cell);\n      }\n    }\n    return nodes;\n  };\n\n  updateNeighbourDistances = (currentCell: DijkstraCell) => {\n    const updateDistance = (currentCell: DijkstraCell, targetCell: DijkstraCell) => {\n      targetCell.distanceFromSource =\n        currentCell.distanceFromSource + targetCell.moveCost;\n    };\n\n    const neighbours = this.getUnvisitedNeighbours(currentCell);\n    neighbours.forEach((cell) => {\n      updateDistance(currentCell, cell);\n    });\n  };\n\n  solve = () => {\n    const sortNodesByDistance = (nodeList: DijkstraCell[]) => {\n      return nodeList.sort(\n        (firstNode, secondNode) =>\n          firstNode.distanceFromSource - secondNode.distanceFromSource\n      );\n    };\n\n    const t0 = performance.now();\n\n    const exitCell = this.grid[this.width - 1][this.height - 1];\n    const unvisitedCells = this.getAllNodes();\n    const startCell = this.grid[0][0];\n    startCell.distanceFromSource = 0;\n\n    while (!!unvisitedCells.length) {\n      sortNodesByDistance(unvisitedCells);\n      const currentCell = unvisitedCells.shift();\n\n      if (currentCell === undefined) break;\n      if (currentCell.distanceFromSource === Infinity) break;\n      if (currentCell === exitCell) break;\n\n      currentCell.visited = true;\n\n      this.updateNeighbourDistances(currentCell);\n      this.frames.push(cloneDeep(this.grid));\n    }\n\n    let currentCell = exitCell;\n\n    while (!(currentCell === startCell)) {\n      currentCell.onPath = true;\n      const nextCell = this.getBestPathNeighbor(currentCell);\n      this.frames.push(cloneDeep(this.grid));\n      currentCell = nextCell;\n    }\n\n    startCell.onPath = true;\n    this.frames.push(cloneDeep(this.grid));\n\n    const t1 = performance.now();\n    console.log(\"solved in:\", t1 - t0, \"milliseconds.\");\n  };\n\n  draw(canvasContext: any, unitSize: number, step: number) {\n    canvasContext.clearRect(0, 0, unitSize * this.width, unitSize * this.height);\n    if (this.frames[step] === undefined) return;\n    canvasContext.strokeStyle = \"#800080\";\n    canvasContext.lineWidth = 5;\n    canvasContext.beginPath();\n    this.frames[step].forEach((row) => {\n      row.forEach((cell) => {\n        if (cell.visited) {\n          canvasContext.fillStyle = \"#FDA4BA\";\n          canvasContext.fillRect(\n            cell.x * unitSize,\n            cell.y * unitSize,\n            unitSize + 1,\n            unitSize + 1\n          );\n        }\n\n        if (cell.onPath) {\n          canvasContext.fillStyle = \"#00BFFF\";\n          canvasContext.fillRect(\n            cell.x * unitSize,\n            cell.y * unitSize,\n            unitSize,\n            unitSize\n          );\n        }\n\n        canvasContext.moveTo(cell.x * unitSize - 2.5, cell.y * unitSize);\n        if (cell.walls.N) {\n          canvasContext.lineTo(cell.x * unitSize + unitSize, cell.y * unitSize);\n        } else {\n          canvasContext.moveTo(cell.x * unitSize + unitSize, cell.y * unitSize);\n        }\n        if (cell.walls.E) {\n          canvasContext.lineTo(\n            cell.x * unitSize + unitSize,\n            cell.y * unitSize + unitSize\n          );\n        } else {\n          canvasContext.moveTo(\n            cell.x * unitSize + unitSize,\n            cell.y * unitSize + unitSize\n          );\n        }\n        if (cell.walls.S) {\n          canvasContext.lineTo(cell.x * unitSize, cell.y * unitSize + unitSize);\n        } else {\n          canvasContext.moveTo(cell.x * unitSize, cell.y * unitSize + unitSize);\n        }\n        if (cell.walls.W) {\n          canvasContext.lineTo(cell.x * unitSize, cell.y * unitSize);\n        } else {\n          canvasContext.moveTo(cell.x * unitSize, cell.y * unitSize);\n        }\n      });\n    });\n    canvasContext.stroke();\n\n    canvasContext.beginPath();\n    canvasContext.lineJoin = \"round\";\n    canvasContext.lineWidth = 10;\n    canvasContext.rect(0, 0, this.width * unitSize, this.height * unitSize);\n    canvasContext.stroke();\n\n    canvasContext.beginPath();\n    canvasContext.lineWidth = 10;\n    canvasContext.strokeStyle = \"#FFFFFF\";\n    canvasContext.moveTo(0, 5);\n    canvasContext.lineTo(0, unitSize - 2.5);\n    canvasContext.moveTo(this.width * unitSize, this.height * unitSize - 5);\n    canvasContext.lineTo(\n      this.width * unitSize,\n      this.height * unitSize - unitSize + 2.5\n    );\n    canvasContext.stroke();\n\n    canvasContext.beginPath();\n    canvasContext.lineWidth = 3;\n    canvasContext.fillStyle = \"#000000\";\n    canvasContext.moveTo(unitSize / 4, unitSize / 4);\n    canvasContext.lineTo(3 * (unitSize / 4), unitSize / 2);\n    canvasContext.lineTo(unitSize / 4, 3 * (unitSize / 4));\n    canvasContext.fill();\n\n    canvasContext.beginPath();\n    canvasContext.moveTo(\n      this.width * unitSize - 3 * (unitSize / 4),\n      this.height * unitSize - 3 * (unitSize / 4)\n    );\n    canvasContext.lineTo(\n      this.width * unitSize - unitSize / 4,\n      this.height * unitSize - unitSize / 2\n    );\n    canvasContext.lineTo(\n      this.width * unitSize - 3 * (unitSize / 4),\n      this.height * unitSize - unitSize / 4\n    );\n    canvasContext.fill();\n  }\n}\n","import Maze from \"./Maze\";\n\nexport default Maze","import React, { useState } from \"react\";\nimport styles from \"./Maze.module.scss\";\nimport {\n  Grid,\n  RecursiveBacktrackMaze,\n  RecursiveDivisionMaze,\n} from \"../../service/mazeGenerator.service\";\nimport Canvas from \"./Canvas/Canvas\";\nimport { cloneDeep } from \"lodash\";\nimport { DijkstraMaze } from \"../../service/mazeSolver.service\";\n\nconst Maze = () => {\n  const [dimensions] = useState({ width: 15, height: 10 });\n  const [maze, setMaze] = useState(new Grid(dimensions.width, dimensions.height));\n  const [delayBetweenFrames, setFrameDelay] = useState(1);\n\n  const handleChange = (event: any): void => {\n    let newDelay = Number(event.target.value);\n    newDelay = Math.max(newDelay, 0);\n    newDelay = Math.min(newDelay, 2000);\n    setFrameDelay(newDelay);\n  };\n\n  console.log(maze);\n  return (\n    <div className={styles.mazeContainer}>\n      <div className={styles.maze} id=\"maze\">\n        <Canvas maze={maze} delayBetweenFrames={delayBetweenFrames} />\n        <div>\n          <button\n            onClick={() => {\n              setMaze(cloneDeep(maze));\n            }}\n          >\n            Re-run\n          </button>\n          <button\n            onClick={() => {\n              setMaze(\n                new RecursiveBacktrackMaze(dimensions.width, dimensions.height)\n              );\n            }}\n          >\n            New Backtrack maze\n          </button>\n          <button\n            onClick={() => {\n              setMaze(\n                new RecursiveDivisionMaze(dimensions.width, dimensions.height)\n              );\n            }}\n          >\n            New Division maze\n          </button>\n          Interval:{\" \"}\n          <input\n            type=\"number\"\n            min=\"1\"\n            max=\"1000\"\n            step=\"10\"\n            defaultValue={delayBetweenFrames}\n            onChange={handleChange}\n          />{\" \"}\n          ms.\n          <button\n            onClick={() => {\n              setMaze(new DijkstraMaze(maze));\n            }}\n          >\n            Solve\n          </button>\n        </div>\n      </div>\n    </div>\n  );\n};\n\nexport default Maze;\n","import React from 'react';\nimport './App.css';\nimport SelectionBar from './components/SelectionBar';\nimport Maze from './components/Maze';\n\nfunction App() {\n  return (\n    <div className='App'>\n    <SelectionBar />\n    <Maze />\n    </div>\n  );\n}\n\nexport default App;\n","import { ReportHandler } from 'web-vitals';\n\nconst reportWebVitals = (onPerfEntry?: ReportHandler) => {\n  if (onPerfEntry && onPerfEntry instanceof Function) {\n    import('web-vitals').then(({ getCLS, getFID, getFCP, getLCP, getTTFB }) => {\n      getCLS(onPerfEntry);\n      getFID(onPerfEntry);\n      getFCP(onPerfEntry);\n      getLCP(onPerfEntry);\n      getTTFB(onPerfEntry);\n    });\n  }\n};\n\nexport default reportWebVitals;\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport reportWebVitals from './reportWebVitals';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n// If you want to start measuring performance in your app, pass a function\n// to log results (for example: reportWebVitals(console.log))\n// or send to an analytics endpoint. Learn more: https://bit.ly/CRA-vitals\nreportWebVitals();\n"],"sourceRoot":""}