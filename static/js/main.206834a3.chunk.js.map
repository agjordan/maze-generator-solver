{"version":3,"sources":["components/Maze/Maze.module.scss","components/SelectionBar/SelectionBar.module.scss","components/SelectionBar/index.ts","components/SelectionBar/SelectionBar.tsx","service/mazeGenerator.service.ts","components/Maze/Canvas/Canvas.tsx","service/mazeSolver.service.ts","components/Maze/index.ts","components/Maze/Maze.tsx","App.tsx","reportWebVitals.ts","index.tsx"],"names":["module","exports","SelectionBar","className","styles","selectionBar","getNeighbourDirections","grid","relativeX","relativeY","directions","push","length","getOppositeDirection","direction","getRandomIntInclusive","min","max","Math","ceil","floor","random","getCellFromDirection","setWallForCellAndNeighbour","cell","addWalls","walls","firstX","x","firstY","y","abs","includes","neighbour","setWallForCollection","cells","forEach","Walls","N","E","S","W","this","EmptyWalls","Cell","visited","backtracked","RecursiveDivisionCell","currentArea","Grid","width","height","stack","frames","algorithm","createFrame","frame","cloneDeep","generateGrid","col","generateMaze","canvasContext","unitSize","step","beginPath","strokeStyle","lineWidth","fillStyle","fillRect","moveTo","lineTo","stroke","lineJoin","rect","fill","RecursiveBacktrackMaze","moves","possibleMoves","nextCell","oldCell","pop","t0","performance","now","lastFrame","t1","console","log","RecursiveDivisionMaze","recusiveDivisionGeneration","verticalSpace","index","row","map","randomCell","createHorizontalWallWithGate","half1","half2","slice","column","createVerticalWallWithGate","draw","topRow","botRow","Canvas","maze","delayBetweenFrames","canvasRef","useRef","useState","setStep","measured","setMeasured","setUnitSize","document","createElement","getContext","context","setContext","useEffect","canvas","current","tmpContext","parentDiv","parentElement","offsetWidth","offsetHeight","tempUnitSize","translate","Error","clearRect","font","fillText","setTimeout","ref","DijkstraCell","distanceFromSource","moveCost","onPath","Infinity","distance","DijkstraSolve","getUnvisitedNeighbours","cellWalls","Object","entries","key","filter","n","move","cellFromDirection","candidate","getAllNodes","nodes","updateNeighbourDistances","currentCell","targetCell","updateDistance","solve","exitCell","unvisitedCells","startCell","sort","firstNode","secondNode","shift","undefined","getBestPathNeighbor","reduce","lowest","Maze","dimensions","setMaze","setFrameDelay","mazeContainer","id","onClick","type","defaultValue","onChange","event","newDelay","Number","target","value","App","reportWebVitals","onPerfEntry","Function","then","getCLS","getFID","getFCP","getLCP","getTTFB","ReactDOM","render","StrictMode","getElementById"],"mappings":"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","file":"static/js/main.206834a3.chunk.js","sourcesContent":["// extracted by mini-css-extract-plugin\nmodule.exports = {\"mazeContainer\":\"Maze_mazeContainer__3Exuk\",\"maze\":\"Maze_maze__2NaIp\"};","// extracted by mini-css-extract-plugin\nmodule.exports = {\"selectionBar\":\"SelectionBar_selectionBar__14QJ9\"};","import SelectionBar from \"./SelectionBar\";\n\nexport default SelectionBar","import React from 'react'\nimport styles from './SelectionBar.module.scss'\n\nconst SelectionBar = () => {\n    return (\n        <div className={styles.selectionBar}>\n            <h1>Maze Generator</h1>\n        </div>\n    )\n}\n\nexport default SelectionBar\n","import { cloneDeep } from \"lodash\";\n\nconst possibleMoves = (cell: Cell, grid: Cell[][]): string[] => {\n  let moves = [];\n  if (cell.y - 1 >= 0 && !grid[cell.x][cell.y - 1].visited) moves.push(\"N\");\n  if (cell.x + 1 < grid.length && !grid[cell.x + 1][cell.y].visited) moves.push(\"E\");\n  if (cell.y + 1 < grid[0].length && !grid[cell.x][cell.y + 1].visited)\n    moves.push(\"S\");\n  if (cell.x - 1 >= 0 && !grid[cell.x - 1][cell.y].visited) moves.push(\"W\");\n  return moves;\n};\n\nconst getNeighbourDirections = (\n  grid: Cell[][],\n  relativeX: number,\n  relativeY: number\n) => {\n  let directions = [];\n  if (relativeY - 1 >= 0) directions.push(\"N\");\n  if (relativeX + 1 < grid.length) directions.push(\"E\");\n  if (relativeY + 1 < grid[0].length) directions.push(\"S\");\n  if (relativeX - 1 >= 0) directions.push(\"W\");\n  return directions;\n};\n\nconst getOppositeDirection = (direction: string): string | null => {\n  switch (direction) {\n    case \"N\":\n      return \"S\";\n    case \"E\":\n      return \"W\";\n    case \"S\":\n      return \"N\";\n    case \"W\":\n      return \"E\";\n    default:\n      return null;\n  }\n};\n\nconst getRandomIntInclusive = (min: number, max: number): number => {\n  min = Math.ceil(min);\n  max = Math.floor(max);\n  return Math.floor(Math.random() * (max - min + 1) + min);\n};\n\nconst getCellFromDirection = (\n  direction: string,\n  grid: Cell[][],\n  relativeX: number,\n  relativeY: number\n): Cell | undefined => {\n  switch (direction) {\n    case \"N\":\n      if (relativeY - 1 >= 0) return grid[relativeX][relativeY - 1];\n      return undefined;\n    case \"E\":\n      if (relativeX + 1 < grid.length) return grid[relativeX + 1][relativeY];\n      return undefined;\n    case \"S\":\n      if (relativeY + 1 < grid[0].length) return grid[relativeX][relativeY + 1];\n      return undefined;\n    case \"W\":\n      if (relativeX - 1 >= 0) return grid[relativeX - 1][relativeY];\n      return undefined;\n    default:\n      return undefined;\n  }\n};\n\nconst setWallForCellAndNeighbour = (\n  cell: Cell,\n  direction: string,\n  grid: Cell[][],\n  addWalls: boolean = true\n) => {\n  cell.walls[direction] = addWalls;\n\n  const firstX = grid[0][0].x;\n  const firstY = grid[0][0].y;\n\n  const relativeX = Math.abs(firstX - cell.x);\n  const relativeY = Math.abs(firstY - cell.y);\n\n  if (getNeighbourDirections(grid, relativeX, relativeY).includes(direction)) {\n    const neighbour = getCellFromDirection(direction, grid, relativeX, relativeY);\n    if (neighbour) neighbour.walls[getOppositeDirection(direction)!] = addWalls;\n  }\n};\n\nconst setWallForCollection = (\n  cells: Cell[],\n  direction: string,\n  grid: Cell[][],\n  addWalls: boolean\n) => {\n  cells.forEach((cell) =>\n    setWallForCellAndNeighbour(cell, direction, grid, addWalls)\n  );\n};\n\nconst createHorizontalWallWithGate = (\n  index: number,\n  grid: RecursiveDivisionCell[][]\n): void => {\n  const row = grid.map((col) => col[index]);\n  setWallForCollection(row, \"S\", grid, true);\n\n  const randomCell = row[getRandomIntInclusive(1, row.length - 2)];\n  setWallForCellAndNeighbour(randomCell, \"S\", grid, false);\n};\n\nconst createVerticalWallWithGate = (\n  index: number,\n  grid: RecursiveDivisionCell[][]\n): void => {\n  const column = grid[index];\n\n  setWallForCollection(column, \"E\", grid, true);\n\n  const randomCell = column[getRandomIntInclusive(1, column.length - 2)];\n  setWallForCellAndNeighbour(randomCell, \"E\", grid, false);\n};\n\nexport class Walls {\n  N: boolean;\n  E: boolean;\n  S: boolean;\n  W: boolean;\n  [key: string]: boolean;\n\n  constructor() {\n    this.N = true;\n    this.E = true;\n    this.S = true;\n    this.W = true;\n  }\n}\n\nexport class EmptyWalls extends Walls {\n  constructor() {\n    super();\n    this.N = false;\n    this.E = false;\n    this.S = false;\n    this.W = false;\n  }\n}\n\nexport class Cell {\n  x: number;\n  y: number;\n  walls: Walls;\n  visited: boolean;\n  backtracked: boolean;\n\n  constructor(x: number, y: number) {\n    this.x = x;\n    this.y = y;\n    this.walls = new Walls();\n    this.visited = false;\n    this.backtracked = false;\n  }\n}\n\nexport class RecursiveDivisionCell extends Cell {\n  currentArea: boolean;\n\n  constructor(x: number, y: number) {\n    super(x, y);\n    this.walls = new EmptyWalls();\n    this.currentArea = true;\n  }\n}\n\nexport class Grid {\n  height: number;\n  width: number;\n  grid: Cell[][];\n  stack: Cell[];\n  frames: Cell[][][];\n  algorithm: string;\n  [key: string]: any;\n\n  constructor(width: number, height: number) {\n    this.height = height <= 50 ? height : 50;\n    this.width = width <= 50 ? width : 50;\n    this.grid = [];\n    this.stack = [];\n    this.algorithm = \"grid\";\n\n    this.generateGrid();\n    this.frames = [cloneDeep(this.grid)];\n  }\n\n  createFrame = (frame: Cell[][] = []) => {\n    if (frame.length < 1) frame = cloneDeep(this.grid);\n    this.frames.push(cloneDeep(frame));\n  };\n\n  generateGrid = () => {\n    for (let x = 0; x < this.width; x++) {\n      let col = [];\n      for (let y = 0; y < this.height; y++) {\n        col.push(new Cell(x, y));\n      }\n      this.grid.push(col);\n    }\n  };\n  generateMaze = (cell: Cell) => {};\n\n  draw(canvasContext: any, unitSize: number, step: number) {\n    // canvasContext.clearRect(0, 0, unitSize * this.width, unitSize * this.height);\n    canvasContext.beginPath();\n    this.frames[step].forEach((col) => {\n      canvasContext.strokeStyle = \"#800080\";\n      canvasContext.lineWidth = 5;\n      col.forEach((cell) => {\n        canvasContext.fillStyle = \"#FDA4BA\";\n        if (cell.visited && !cell.backtracked) {\n          canvasContext.fillRect(\n            cell.x * unitSize,\n            cell.y * unitSize,\n            unitSize + 1,\n            unitSize + 1\n          );\n        }\n        canvasContext.moveTo(cell.x * unitSize - 2.5, cell.y * unitSize);\n        if (cell.walls.N) {\n          canvasContext.lineTo(cell.x * unitSize + unitSize, cell.y * unitSize);\n        } else {\n          canvasContext.moveTo(cell.x * unitSize + unitSize, cell.y * unitSize);\n        }\n        if (cell.walls.E) {\n          canvasContext.lineTo(\n            cell.x * unitSize + unitSize,\n            cell.y * unitSize + unitSize\n          );\n        } else {\n          canvasContext.moveTo(\n            cell.x * unitSize + unitSize,\n            cell.y * unitSize + unitSize\n          );\n        }\n        if (cell.walls.S) {\n          canvasContext.lineTo(cell.x * unitSize, cell.y * unitSize + unitSize);\n        } else {\n          canvasContext.moveTo(cell.x * unitSize, cell.y * unitSize + unitSize);\n        }\n        if (cell.walls.W) {\n          canvasContext.lineTo(cell.x * unitSize, cell.y * unitSize);\n        } else {\n          canvasContext.moveTo(cell.x * unitSize, cell.y * unitSize);\n        }\n      });\n    });\n    canvasContext.stroke();\n\n    canvasContext.beginPath();\n    canvasContext.lineJoin = \"round\";\n    canvasContext.lineWidth = 10;\n    canvasContext.rect(0, 0, this.width * unitSize, this.height * unitSize);\n    canvasContext.stroke();\n\n    canvasContext.beginPath();\n    canvasContext.lineWidth = 10;\n    canvasContext.strokeStyle = \"#FFFFFF\";\n    canvasContext.moveTo(0, 5);\n    canvasContext.lineTo(0, unitSize - 2.5);\n    canvasContext.moveTo(this.width * unitSize, this.height * unitSize - 5);\n    canvasContext.lineTo(\n      this.width * unitSize,\n      this.height * unitSize - unitSize + 2.5\n    );\n    canvasContext.stroke();\n\n    canvasContext.beginPath();\n    canvasContext.lineWidth = 3;\n    canvasContext.fillStyle = \"#000000\";\n    canvasContext.moveTo(unitSize / 4, unitSize / 4);\n    canvasContext.lineTo(3 * (unitSize / 4), unitSize / 2);\n    canvasContext.lineTo(unitSize / 4, 3 * (unitSize / 4));\n    canvasContext.fill();\n\n    canvasContext.beginPath();\n    canvasContext.moveTo(\n      this.width * unitSize - 3 * (unitSize / 4),\n      this.height * unitSize - 3 * (unitSize / 4)\n    );\n    canvasContext.lineTo(\n      this.width * unitSize - unitSize / 4,\n      this.height * unitSize - unitSize / 2\n    );\n    canvasContext.lineTo(\n      this.width * unitSize - 3 * (unitSize / 4),\n      this.height * unitSize - unitSize / 4\n    );\n    canvasContext.fill();\n  }\n}\n\nexport class RecursiveBacktrackMaze extends Grid {\n  constructor(width: number, height: number) {\n    super(width, height);\n    const t0 = performance.now();\n    this.algorithm = \"recursiveBacktrackGenerate\";\n\n    this.generateMaze(this.grid[0][0]);\n\n    let lastFrame = this.frames.pop();\n    if (lastFrame) {\n      lastFrame[0][0].backtracked = true;\n      this.createFrame(cloneDeep(lastFrame));\n    }\n    const t1 = performance.now();\n    console.log(\"maze generated in: \", t1 - t0, \" milliseconds.\");\n  }\n\n  generateMaze = (cell: Cell) => {\n    cell.visited = true;\n    this.createFrame();\n\n    const directions = possibleMoves(cell, this.grid);\n    const direction = directions[getRandomIntInclusive(0, directions.length - 1)];\n    const nextCell = getCellFromDirection(direction, this.grid, cell.x, cell.y);\n\n    if (!nextCell && this.stack.length < 1) return;\n\n    if (nextCell) {\n      setWallForCellAndNeighbour(cell, direction, this.grid, false);\n      this.stack.push(cell);\n      this.generateMaze(nextCell);\n    } else {\n      cell.backtracked = true;\n      const oldCell = this.stack.pop();\n      if (oldCell) {\n        this.generateMaze(oldCell);\n      }\n    }\n  };\n\n  draw(canvasContext: any, unitSize: number, step: number) {\n    // canvasContext.clearRect(0, 0, unitSize * this.width, unitSize * this.height);\n    canvasContext.beginPath();\n    this.frames[step].forEach((col) => {\n      canvasContext.strokeStyle = \"#800080\";\n      canvasContext.lineWidth = 5;\n      col.forEach((cell) => {\n        canvasContext.fillStyle = \"#FDA4BA\";\n        if (cell.visited && !cell.backtracked) {\n          canvasContext.fillRect(\n            cell.x * unitSize,\n            cell.y * unitSize,\n            unitSize + 1,\n            unitSize + 1\n          );\n        }\n        canvasContext.moveTo(cell.x * unitSize - 2.5, cell.y * unitSize);\n        if (cell.walls.N) {\n          canvasContext.lineTo(cell.x * unitSize + unitSize, cell.y * unitSize);\n        } else {\n          canvasContext.moveTo(cell.x * unitSize + unitSize, cell.y * unitSize);\n        }\n        if (cell.walls.E) {\n          canvasContext.lineTo(\n            cell.x * unitSize + unitSize,\n            cell.y * unitSize + unitSize\n          );\n        } else {\n          canvasContext.moveTo(\n            cell.x * unitSize + unitSize,\n            cell.y * unitSize + unitSize\n          );\n        }\n        if (cell.walls.S) {\n          canvasContext.lineTo(cell.x * unitSize, cell.y * unitSize + unitSize);\n        } else {\n          canvasContext.moveTo(cell.x * unitSize, cell.y * unitSize + unitSize);\n        }\n        if (cell.walls.W) {\n          canvasContext.lineTo(cell.x * unitSize, cell.y * unitSize);\n        } else {\n          canvasContext.moveTo(cell.x * unitSize, cell.y * unitSize);\n        }\n      });\n    });\n    canvasContext.stroke();\n\n    canvasContext.beginPath();\n    canvasContext.lineJoin = \"round\";\n    canvasContext.lineWidth = 10;\n    canvasContext.rect(0, 0, this.width * unitSize, this.height * unitSize);\n    canvasContext.stroke();\n\n    canvasContext.beginPath();\n    canvasContext.lineWidth = 10;\n    canvasContext.strokeStyle = \"#FFFFFF\";\n    canvasContext.moveTo(0, 5);\n    canvasContext.lineTo(0, unitSize - 2.5);\n    canvasContext.moveTo(this.width * unitSize, this.height * unitSize - 5);\n    canvasContext.lineTo(\n      this.width * unitSize,\n      this.height * unitSize - unitSize + 2.5\n    );\n    canvasContext.stroke();\n\n    canvasContext.beginPath();\n    canvasContext.lineWidth = 3;\n    canvasContext.fillStyle = \"#000000\";\n    canvasContext.moveTo(unitSize / 4, unitSize / 4);\n    canvasContext.lineTo(3 * (unitSize / 4), unitSize / 2);\n    canvasContext.lineTo(unitSize / 4, 3 * (unitSize / 4));\n    canvasContext.fill();\n\n    canvasContext.beginPath();\n    canvasContext.moveTo(\n      this.width * unitSize - 3 * (unitSize / 4),\n      this.height * unitSize - 3 * (unitSize / 4)\n    );\n    canvasContext.lineTo(\n      this.width * unitSize - unitSize / 4,\n      this.height * unitSize - unitSize / 2\n    );\n    canvasContext.lineTo(\n      this.width * unitSize - 3 * (unitSize / 4),\n      this.height * unitSize - unitSize / 4\n    );\n    canvasContext.fill();\n  }\n}\n\nexport class RecursiveDivisionMaze extends Grid {\n  grid: RecursiveDivisionCell[][];\n  frames: RecursiveDivisionCell[][][];\n\n  constructor(width: number, height: number) {\n    super(width, height);\n    const t0 = performance.now();\n    this.algorithm = \"recursiveDivisionGenerate\";\n    this.grid = [];\n\n    // replace Cells with RecursiveDivisionCells (they have no walls)\n    for (let x = 0; x < width; x++) {\n      let col = [];\n      for (let y = 0; y < height; y++) {\n        col.push(new RecursiveDivisionCell(x, y));\n      }\n      this.grid.push(col);\n    }\n\n    //adding W, E, N, S perimeter walls\n    let topRow: RecursiveDivisionCell[] = [];\n    let botRow: RecursiveDivisionCell[] = [];\n    this.grid.forEach((col) => {\n      topRow.push(col[0]);\n      botRow.push(col[col.length - 1]);\n    });\n    setWallForCollection(topRow, \"N\", this.grid, true);\n    setWallForCollection(botRow, \"S\", this.grid, true);\n    setWallForCollection(this.grid[0], \"W\", this.grid, true);\n    setWallForCollection(this.grid[this.grid.length - 1], \"E\", this.grid, true);\n\n    this.frames = [this.grid];\n\n    this.generateMaze();\n\n    const t1 = performance.now();\n    console.log(\"maze generated in: \", t1 - t0, \" milliseconds.\");\n  }\n\n  generateMaze = (): void => {\n    const recusiveDivisionGeneration = (grid: RecursiveDivisionCell[][]) => {\n      let width: number;\n      let height: number;\n      let verticalSpace: boolean;\n\n      width = grid.length;\n      height = grid[0].length;\n      verticalSpace = width < height;\n\n      //exit condition to ensure we don't have an endless loop, also controls size of final rooms\n      if (width <= 1 || height <= 1) return;\n\n      this.grid.forEach((col) => col.forEach((cell) => (cell.currentArea = false)));\n      grid.forEach((col) => col.forEach((cell) => (cell.currentArea = true)));\n      this.createFrame();\n\n      if (verticalSpace) {\n        const index = getRandomIntInclusive(0, height - 2);\n\n        createHorizontalWallWithGate(index, grid);\n        this.createFrame();\n\n        //split and recurse\n        let half1: RecursiveDivisionCell[][] = [];\n        let half2: RecursiveDivisionCell[][] = [];\n\n        grid.forEach((col) => {\n          half1.push(col.slice(0, index + 1));\n          half2.push(col.slice(index + 1));\n        });\n        if (!!half1[0].length) recusiveDivisionGeneration(half1);\n        if (!!half2[0].length) recusiveDivisionGeneration(half2);\n      } else {\n        const index = getRandomIntInclusive(0, width - 2);\n\n        createVerticalWallWithGate(index, grid);\n        this.createFrame();\n\n        const half1 = grid.slice(0, index + 1);\n        const half2 = grid.slice(index + 1);\n        if (!!half1.length) recusiveDivisionGeneration(half1);\n        if (!!half2.length) recusiveDivisionGeneration(half2);\n      }\n    };\n\n    this.frames = [this.grid];\n    recusiveDivisionGeneration(this.grid);\n    this.grid.forEach((col) => col.forEach((cell) => (cell.currentArea = false)));\n    this.frames.push(cloneDeep(this.grid));\n  };\n\n  draw = (canvasContext: any, unitSize: number, step: number) => {\n    // canvasContext.clearRect(0, 0, unitSize * this.width, unitSize * this.height);\n    canvasContext.beginPath();\n\n    if (!this.frames[step]) return;\n\n    this.frames[step].forEach((col) => {\n      canvasContext.strokeStyle = \"#800080\";\n      canvasContext.lineWidth = 5;\n      col.forEach((cell) => {\n        canvasContext.fillStyle = \"#FDA4BA\";\n        if (cell.currentArea) {\n          canvasContext.fillRect(\n            cell.x * unitSize,\n            cell.y * unitSize,\n            unitSize + 1,\n            unitSize + 1\n          );\n        }\n        canvasContext.moveTo(cell.x * unitSize - 2.5, cell.y * unitSize);\n        if (cell.walls.N) {\n          canvasContext.lineTo(cell.x * unitSize + unitSize, cell.y * unitSize);\n        } else {\n          canvasContext.moveTo(cell.x * unitSize + unitSize, cell.y * unitSize);\n        }\n        if (cell.walls.E) {\n          canvasContext.lineTo(\n            cell.x * unitSize + unitSize,\n            cell.y * unitSize + unitSize\n          );\n        } else {\n          canvasContext.moveTo(\n            cell.x * unitSize + unitSize,\n            cell.y * unitSize + unitSize\n          );\n        }\n        if (cell.walls.S) {\n          canvasContext.lineTo(cell.x * unitSize, cell.y * unitSize + unitSize);\n        } else {\n          canvasContext.moveTo(cell.x * unitSize, cell.y * unitSize + unitSize);\n        }\n        if (cell.walls.W) {\n          canvasContext.lineTo(cell.x * unitSize, cell.y * unitSize);\n        } else {\n          canvasContext.moveTo(cell.x * unitSize, cell.y * unitSize);\n        }\n      });\n    });\n    canvasContext.stroke();\n\n    canvasContext.beginPath();\n    canvasContext.lineJoin = \"round\";\n    canvasContext.lineWidth = 10;\n    canvasContext.rect(0, 0, this.width * unitSize, this.height * unitSize);\n    canvasContext.stroke();\n\n    canvasContext.beginPath();\n    canvasContext.lineWidth = 10;\n    canvasContext.strokeStyle = \"#FFFFFF\";\n    canvasContext.moveTo(0, 5);\n    canvasContext.lineTo(0, unitSize - 2.5);\n    canvasContext.moveTo(this.width * unitSize, this.height * unitSize - 5);\n    canvasContext.lineTo(\n      this.width * unitSize,\n      this.height * unitSize - unitSize + 2.5\n    );\n    canvasContext.stroke();\n\n    canvasContext.beginPath();\n    canvasContext.lineWidth = 3;\n    canvasContext.fillStyle = \"#000000\";\n    canvasContext.moveTo(unitSize / 4, unitSize / 4);\n    canvasContext.lineTo(3 * (unitSize / 4), unitSize / 2);\n    canvasContext.lineTo(unitSize / 4, 3 * (unitSize / 4));\n    canvasContext.fill();\n\n    canvasContext.beginPath();\n    canvasContext.moveTo(\n      this.width * unitSize - 3 * (unitSize / 4),\n      this.height * unitSize - 3 * (unitSize / 4)\n    );\n    canvasContext.lineTo(\n      this.width * unitSize - unitSize / 4,\n      this.height * unitSize - unitSize / 2\n    );\n    canvasContext.lineTo(\n      this.width * unitSize - 3 * (unitSize / 4),\n      this.height * unitSize - unitSize / 4\n    );\n    canvasContext.fill();\n  };\n}\n","import React, { useRef, useEffect, useState } from \"react\";\nimport {\n  Grid,\n  RecursiveBacktrackMaze,\n} from \"../../../service/mazeGenerator.service\";\nimport { DijkstraSolve } from \"../../../service/mazeSolver.service\";\n\ntype CanvasProps = {\n  maze: Grid | RecursiveBacktrackMaze | DijkstraSolve;\n  delayBetweenFrames: number;\n};\n\nconst Canvas = ({ maze, delayBetweenFrames }: CanvasProps) => {\n  const canvasRef = useRef(null);\n  const [step, setStep] = useState(0);\n  const [measured, setMeasured] = useState(false);\n  const [unitSize, setUnitSize] = useState(1);\n  const [context, setContext] = useState(\n    document.createElement(\"canvas\").getContext(\"2d\")\n  );\n\n  useEffect(() => {\n    setStep(0);\n    const canvas: any = canvasRef.current;\n    const tmpContext = canvas.getContext(\"2d\");\n    const parentDiv = canvas.parentElement;\n    if (!measured) {\n      tmpContext.canvas.width = parentDiv?.offsetWidth;\n      tmpContext.canvas.height = parentDiv?.offsetHeight;\n      let tempUnitSize = 1;\n      while (\n        tempUnitSize * maze.height < tmpContext.canvas.height - 50 &&\n        tempUnitSize * maze.width < tmpContext.canvas.width - 50\n      ) {\n        tempUnitSize += 1;\n      }\n      setUnitSize(tempUnitSize);\n      setMeasured(true);\n      tmpContext.translate(5, 5);\n      setContext(tmpContext);\n    }\n  }, [maze, measured]);\n\n  useEffect(() => {\n    if (!context) throw new Error(\"No context\");\n\n    context.clearRect(\n      0,\n      0,\n      maze.width * unitSize + 300,\n      maze.height * unitSize + 100\n    );\n    context.font = \"20px Roboto\";\n    context.fillText(\n      `${step + 1} / ${maze.frames.length}`,\n      0,\n      maze.height * unitSize + 30\n    );\n    maze.draw(context, unitSize, step);\n\n    setTimeout(() => {\n      if (step + 1 < maze.frames.length) setStep(step + 1);\n    }, delayBetweenFrames);\n  }, [step, context, maze, unitSize, delayBetweenFrames]);\n\n  return <canvas ref={canvasRef} />;\n};\n\nexport default Canvas;\n","import { Walls, Cell, Grid, RecursiveDivisionCell } from \"./mazeGenerator.service\";\nimport { cloneDeep } from \"lodash\";\n\nclass CellForSolving extends Cell {\n  visited: boolean;\n  walls: Walls;\n\n  constructor(cell: Cell) {\n    super(cell.x, cell.y);\n    this.visited = false;\n    this.walls = cell.walls;\n  }\n}\n\nclass DijkstraCell extends CellForSolving {\n  distanceFromSource: number;\n  moveCost: number;\n  onPath: boolean;\n\n  constructor(cell: Cell) {\n    super(cell);\n    this.distanceFromSource = Infinity;\n    this.moveCost = 1;\n    this.onPath = false;\n  }\n\n  setDistanceFromSource(distance: number) {\n    this.distanceFromSource = distance;\n  }\n}\n\nexport class DijkstraSolve extends Grid {\n  grid: DijkstraCell[][];\n  frames: DijkstraCell[][][];\n\n  constructor(maze: Grid) {\n    super(maze.width, maze.height);\n    this.frames = [];\n    this.algorithm = \"DijkstraSolve\";\n\n    this.grid = maze.grid.map((row: RecursiveDivisionCell[] | Cell[]) => {\n      return row.map((cell: RecursiveDivisionCell | Cell) => {\n        return new DijkstraCell(cell);\n      });\n    });\n\n    this.solve();\n  }\n\n  getUnvisitedNeighbours = (cell: DijkstraCell): DijkstraCell[] => {\n    let allMoves = [\"N\", \"E\", \"S\", \"W\"];\n    let cellWalls: string[] = [];\n\n    Object.entries(cell.walls).forEach(([key, value]) => {\n      if (value) cellWalls.push(key);\n    });\n\n    const cellFromDirection = (direction: string): DijkstraCell | null => {\n      switch (direction) {\n        case \"N\":\n          if (!this.grid[cell.x][cell.y - 1]?.visited)\n            return this.grid[cell.x][cell.y - 1];\n          return null;\n        case \"E\":\n          if (!this.grid[cell.x + 1][cell.y]?.visited)\n            return this.grid[cell.x + 1][cell.y];\n          return null;\n        case \"S\":\n          if (!this.grid[cell.x][cell.y + 1]?.visited)\n            return this.grid[cell.x][cell.y + 1];\n          return null;\n        case \"W\":\n          if (!this.grid[cell.x - 1][cell.y]?.visited)\n            return this.grid[cell.x - 1][cell.y];\n          return null;\n        default:\n          return null;\n      }\n    };\n\n    const isCell = (candidate: any): candidate is DijkstraCell => {\n      if (candidate instanceof DijkstraCell) return true;\n      return false;\n    };\n\n    const cellMoves = allMoves\n      .filter((n) => !cellWalls.includes(n))\n      .map((move) => cellFromDirection(move));\n    const validMoves: DijkstraCell[] = cellMoves.filter(isCell)!;\n\n    return validMoves;\n  };\n\n  getBestPathNeighbor(cell: DijkstraCell) {\n    let allMoves = [\"N\", \"E\", \"S\", \"W\"];\n    let cellWalls: string[] = [];\n\n    Object.entries(cell.walls).forEach(([key, value]) => {\n      if (value) cellWalls.push(key);\n    });\n\n    const cellFromDirection = (direction: string): DijkstraCell | null => {\n      switch (direction) {\n        case \"N\":\n          if (!this.grid[cell.x][cell.y - 1]?.onPath)\n            return this.grid[cell.x][cell.y - 1];\n          return null;\n        case \"E\":\n          if (!this.grid[cell.x + 1][cell.y]?.onPath)\n            return this.grid[cell.x + 1][cell.y];\n          return null;\n        case \"S\":\n          if (!this.grid[cell.x][cell.y + 1]?.onPath)\n            return this.grid[cell.x][cell.y + 1];\n          return null;\n        case \"W\":\n          if (!this.grid[cell.x - 1][cell.y]?.onPath)\n            return this.grid[cell.x - 1][cell.y];\n          return null;\n        default:\n          return null;\n      }\n    };\n\n    const isCell = (candidate: any): candidate is DijkstraCell => {\n      if (candidate instanceof DijkstraCell) return true;\n      return false;\n    };\n\n    const cellMoves = allMoves\n      .filter((n) => !cellWalls.includes(n))\n      .map((move) => cellFromDirection(move));\n    const validMoves: DijkstraCell[] = cellMoves.filter(isCell)!;\n\n    return validMoves.reduce((lowest, cell) =>\n      lowest.distanceFromSource < cell.distanceFromSource ? lowest : cell\n    );\n  }\n\n  getAllNodes = (): DijkstraCell[] => {\n    let nodes: DijkstraCell[] = [];\n    for (let row of this.grid) {\n      for (let cell of row) {\n        nodes.push(cell);\n      }\n    }\n    return nodes;\n  };\n\n  updateNeighbourDistances = (currentCell: DijkstraCell) => {\n    const updateDistance = (currentCell: DijkstraCell, targetCell: DijkstraCell) => {\n      targetCell.distanceFromSource =\n        currentCell.distanceFromSource + targetCell.moveCost;\n    };\n\n    const neighbours = this.getUnvisitedNeighbours(currentCell);\n    neighbours.forEach((cell) => {\n      updateDistance(currentCell, cell);\n    });\n  };\n\n  solve = () => {\n    const sortNodesByDistance = (nodeList: DijkstraCell[]) => {\n      return nodeList.sort(\n        (firstNode, secondNode) =>\n          firstNode.distanceFromSource - secondNode.distanceFromSource\n      );\n    };\n\n    const t0 = performance.now();\n\n    const exitCell = this.grid[this.width - 1][this.height - 1];\n    const unvisitedCells = this.getAllNodes();\n    const startCell = this.grid[0][0];\n    startCell.distanceFromSource = 0;\n\n    while (!!unvisitedCells.length) {\n      sortNodesByDistance(unvisitedCells);\n      const currentCell = unvisitedCells.shift();\n\n      if (currentCell === undefined) break;\n      if (currentCell.distanceFromSource === Infinity) break;\n      if (currentCell === exitCell) break;\n\n      currentCell.visited = true;\n\n      this.updateNeighbourDistances(currentCell);\n      this.frames.push(cloneDeep(this.grid));\n    }\n\n    let currentCell = exitCell;\n\n    while (!(currentCell === startCell)) {\n      currentCell.onPath = true;\n      const nextCell = this.getBestPathNeighbor(currentCell);\n      this.frames.push(cloneDeep(this.grid));\n      currentCell = nextCell;\n    }\n\n    startCell.onPath = true;\n    this.frames.push(cloneDeep(this.grid));\n\n    const t1 = performance.now();\n    console.log(\"solved in:\", t1 - t0, \"milliseconds.\");\n  };\n\n  draw(canvasContext: any, unitSize: number, step: number) {\n    canvasContext.clearRect(0, 0, unitSize * this.width, unitSize * this.height);\n    if (this.frames[step] === undefined) return;\n    canvasContext.strokeStyle = \"#800080\";\n    canvasContext.lineWidth = 5;\n    canvasContext.beginPath();\n    this.frames[step].forEach((row) => {\n      row.forEach((cell) => {\n        if (cell.visited) {\n          canvasContext.fillStyle = \"#FDA4BA\";\n          canvasContext.fillRect(\n            cell.x * unitSize,\n            cell.y * unitSize,\n            unitSize + 1,\n            unitSize + 1\n          );\n        }\n\n        if (cell.onPath) {\n          canvasContext.fillStyle = \"#00BFFF\";\n          canvasContext.fillRect(\n            cell.x * unitSize,\n            cell.y * unitSize,\n            unitSize,\n            unitSize\n          );\n        }\n\n        canvasContext.moveTo(cell.x * unitSize - 2.5, cell.y * unitSize);\n        if (cell.walls.N) {\n          canvasContext.lineTo(cell.x * unitSize + unitSize, cell.y * unitSize);\n        } else {\n          canvasContext.moveTo(cell.x * unitSize + unitSize, cell.y * unitSize);\n        }\n        if (cell.walls.E) {\n          canvasContext.lineTo(\n            cell.x * unitSize + unitSize,\n            cell.y * unitSize + unitSize\n          );\n        } else {\n          canvasContext.moveTo(\n            cell.x * unitSize + unitSize,\n            cell.y * unitSize + unitSize\n          );\n        }\n        if (cell.walls.S) {\n          canvasContext.lineTo(cell.x * unitSize, cell.y * unitSize + unitSize);\n        } else {\n          canvasContext.moveTo(cell.x * unitSize, cell.y * unitSize + unitSize);\n        }\n        if (cell.walls.W) {\n          canvasContext.lineTo(cell.x * unitSize, cell.y * unitSize);\n        } else {\n          canvasContext.moveTo(cell.x * unitSize, cell.y * unitSize);\n        }\n      });\n    });\n    canvasContext.stroke();\n\n    canvasContext.beginPath();\n    canvasContext.lineJoin = \"round\";\n    canvasContext.lineWidth = 10;\n    canvasContext.rect(0, 0, this.width * unitSize, this.height * unitSize);\n    canvasContext.stroke();\n\n    canvasContext.beginPath();\n    canvasContext.lineWidth = 10;\n    canvasContext.strokeStyle = \"#FFFFFF\";\n    canvasContext.moveTo(0, 5);\n    canvasContext.lineTo(0, unitSize - 2.5);\n    canvasContext.moveTo(this.width * unitSize, this.height * unitSize - 5);\n    canvasContext.lineTo(\n      this.width * unitSize,\n      this.height * unitSize - unitSize + 2.5\n    );\n    canvasContext.stroke();\n\n    canvasContext.beginPath();\n    canvasContext.lineWidth = 3;\n    canvasContext.fillStyle = \"#000000\";\n    canvasContext.moveTo(unitSize / 4, unitSize / 4);\n    canvasContext.lineTo(3 * (unitSize / 4), unitSize / 2);\n    canvasContext.lineTo(unitSize / 4, 3 * (unitSize / 4));\n    canvasContext.fill();\n\n    canvasContext.beginPath();\n    canvasContext.moveTo(\n      this.width * unitSize - 3 * (unitSize / 4),\n      this.height * unitSize - 3 * (unitSize / 4)\n    );\n    canvasContext.lineTo(\n      this.width * unitSize - unitSize / 4,\n      this.height * unitSize - unitSize / 2\n    );\n    canvasContext.lineTo(\n      this.width * unitSize - 3 * (unitSize / 4),\n      this.height * unitSize - unitSize / 4\n    );\n    canvasContext.fill();\n  }\n}\n","import Maze from \"./Maze\";\n\nexport default Maze","import React, { useState } from \"react\";\nimport styles from \"./Maze.module.scss\";\nimport {\n  Grid,\n  RecursiveBacktrackMaze,\n  RecursiveDivisionMaze,\n} from \"../../service/mazeGenerator.service\";\nimport Canvas from \"./Canvas/Canvas\";\nimport { cloneDeep } from \"lodash\";\nimport { DijkstraSolve } from \"../../service/mazeSolver.service\";\n\nconst Maze = () => {\n  const [dimensions] = useState({ width: 15, height: 10 });\n  const [maze, setMaze] = useState(new Grid(dimensions.width, dimensions.height));\n  const [delayBetweenFrames, setFrameDelay] = useState(1);\n\n  const handleChange = (event: any): void => {\n    let newDelay = Number(event.target.value);\n    newDelay = Math.max(newDelay, 0);\n    newDelay = Math.min(newDelay, 2000);\n    setFrameDelay(newDelay);\n  };\n\n  return (\n    <div className={styles.mazeContainer}>\n      <div className={styles.maze} id=\"maze\">\n        <Canvas maze={maze} delayBetweenFrames={delayBetweenFrames} />\n        <div>\n          <button\n            onClick={() => {\n              setMaze(cloneDeep(maze));\n            }}\n          >\n            Re-run\n          </button>\n          <button\n            onClick={() => {\n              setMaze(\n                new RecursiveBacktrackMaze(dimensions.width, dimensions.height)\n              );\n            }}\n          >\n            New Backtrack maze\n          </button>\n          <button\n            onClick={() => {\n              setMaze(\n                new RecursiveDivisionMaze(dimensions.width, dimensions.height)\n              );\n            }}\n          >\n            New Division maze\n          </button>\n          <button\n            onClick={() => {\n              setMaze(new DijkstraSolve(maze));\n            }}\n          >\n            Solve\n          </button>\n          Interval:{\" \"}\n          <input\n            type=\"number\"\n            min=\"1\"\n            max=\"1000\"\n            step=\"10\"\n            defaultValue={delayBetweenFrames}\n            onChange={handleChange}\n          />{\" \"}\n          ms.\n        </div>\n      </div>\n    </div>\n  );\n};\n\nexport default Maze;\n","import React from 'react';\nimport './App.css';\nimport SelectionBar from './components/SelectionBar';\nimport Maze from './components/Maze';\n\nfunction App() {\n  return (\n    <div className='App'>\n    <SelectionBar />\n    <Maze />\n    </div>\n  );\n}\n\nexport default App;\n","import { ReportHandler } from 'web-vitals';\n\nconst reportWebVitals = (onPerfEntry?: ReportHandler) => {\n  if (onPerfEntry && onPerfEntry instanceof Function) {\n    import('web-vitals').then(({ getCLS, getFID, getFCP, getLCP, getTTFB }) => {\n      getCLS(onPerfEntry);\n      getFID(onPerfEntry);\n      getFCP(onPerfEntry);\n      getLCP(onPerfEntry);\n      getTTFB(onPerfEntry);\n    });\n  }\n};\n\nexport default reportWebVitals;\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport reportWebVitals from './reportWebVitals';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n// If you want to start measuring performance in your app, pass a function\n// to log results (for example: reportWebVitals(console.log))\n// or send to an analytics endpoint. Learn more: https://bit.ly/CRA-vitals\nreportWebVitals();\n"],"sourceRoot":""}